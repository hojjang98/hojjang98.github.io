<!DOCTYPE html>
<html lang="ko" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Mining Invariants from Console Logs for System Problem Detection 구조 분석 | HJ&#39;s Security Note</title>
<meta name="keywords" content="Log-Invariants, Anomaly-Detection, Execution-Flow, Linear-Relationships, Rule-Mining, USENIX-ATC, Explainable-AI, Hadoop-Security">
<meta name="description" content="시스템 로그 내 메시지 간의 선형적 상관관계를 분석하여 &lsquo;불변량(Invariants)&lsquo;을 추출하고, 이를 통해 복잡한 분산 시스템의 비정상 실행 흐름을 높은 설명력으로 탐지하는 자동화 기법 연구">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/paper_review/soc_%EB%B3%B4%EC%95%88%EA%B4%80%EC%A0%9C/invariants_mining/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css" integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/paper_review/soc_%EB%B3%B4%EC%95%88%EA%B4%80%EC%A0%9C/invariants_mining/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="HJ&#39;s Security Note (Alt + H)">HJ&#39;s Security Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="소개">
                    <span>소개</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/daily-logs/" title="Daily-Logs">
                    <span>일일 로그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/" title="프로젝트">
                    <span>프로젝트</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/cyber-law-study/" title="Cyber-Law-Study">
                    <span>보안법 공부</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/security-issues-analysis/" title="Security-Issues-Analysis">
                    <span>보안 시사 분석</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>태그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/paper-review/" title="Paper-Review">
                    <span>논문 리뷰</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">홈</a>&nbsp;»&nbsp;<a href="http://localhost:1313/paper_review/">논문 리뷰</a></div>
    <h1 class="post-title entry-hint-parent">
      Mining Invariants from Console Logs for System Problem Detection 구조 분석
    </h1>
    <div class="post-meta"><span title='2025-12-22 00:00:00 +0000 UTC'>2025년 12월 22일</span>

</div>
  </header> 
  <div class="post-content"><h1 id="research-review-mining-invariants-from-console-logs-for-system-problem-detection">Research Review: Mining Invariants from Console Logs for System Problem Detection<a hidden class="anchor" aria-hidden="true" href="#research-review-mining-invariants-from-console-logs-for-system-problem-detection">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2025.12.22<br>
<strong>Keywords:</strong> Log_Invariants, Anomaly_Detection, Execution_Flow, Linear_Relationships, Rule_Mining<br>
<strong>Source:</strong> USENIX ATC 2010 <a href="https://www.usenix.org/legacy/events/atc10/tech/full_papers/Lou.pdf">Paper Link</a></p>
</blockquote>
<hr>
<h2 id="why-this-paper">Why This Paper?<a hidden class="anchor" aria-hidden="true" href="#why-this-paper">#</a></h2>
<h3 id="선정-배경-selection-rationale">선정 배경 (Selection Rationale)<a hidden class="anchor" aria-hidden="true" href="#선정-배경-selection-rationale">#</a></h3>
<p><strong>도메인 탐색 결과:</strong><br>
8주간 보안 컨설팅, OT/ICS, 클라우드 등 8개 도메인 논문을 읽은 결과, <strong>SOC(Security Operations Center)</strong> 가 나의 강점과 흥미에 가장 부합함을 확인. 이제부터는 SOC 전문성 심화를 위한 체계적 학습 단계.</p>
<p><strong>이 논문을 선택한 이유:</strong></p>
<ul>
<li>DeepLog(2017)을 먼저 읽고 <strong>딥러닝 기반 로그 분석</strong>을 이해했으나, AI 이전 시대의 접근법이 궁금했음</li>
<li>&ldquo;규칙 기반 탐지 vs AI 기반 탐지&quot;의 장단점을 비교하여 <strong>SOC 실무에서 언제 무엇을 쓸지</strong> 판단 기준 확보</li>
<li><strong>불변성(Invariant)</strong> 개념이 로그 분석에서 어떻게 작동하는지 이론적 기반 학습</li>
<li>DeepLog과 같은 해(2010년대)에 어떤 연구가 병행되었는지 학계 흐름 파악</li>
</ul>
<p><strong>학습 목표 (Learning Objectives):</strong></p>
<ol>
<li>로그 불변성(Log Invariant)의 개념과 자동 추출 방법 이해</li>
<li>규칙 기반 이상탐지의 강점과 한계를 파악하여 DeepLog과 비교</li>
<li>SOC 실무에서 &ldquo;언제 규칙을, 언제 AI를 쓸 것인가&quot;에 대한 판단 기준 도출</li>
</ol>
<p><strong>연계 학습:</strong></p>
<ul>
<li>DeepLog: 딥러닝으로 로그 시퀀스 학습 → 블랙박스 모델</li>
<li>Invariants Mining: 선형 관계 추출 → 사람이 이해 가능한 화이트박스 모델</li>
</ul>
<hr>
<h2 id="day-1--research-context--motivation">Day 1 – Research Context &amp; Motivation<a hidden class="anchor" aria-hidden="true" href="#day-1--research-context--motivation">#</a></h2>
<p><em>(로그 속 숨겨진 불변의 법칙을 찾아서)</em></p>
<h3 id="1-연구-배경-대규모-분산-시스템의-로그-분석-난제">1. 연구 배경: 대규모 분산 시스템의 로그 분석 난제<a hidden class="anchor" aria-hidden="true" href="#1-연구-배경-대규모-분산-시스템의-로그-분석-난제">#</a></h3>
<h4 id="문제-상황-수동-로그-검사의-한계">문제 상황: 수동 로그 검사의 한계<a hidden class="anchor" aria-hidden="true" href="#문제-상황-수동-로그-검사의-한계">#</a></h4>
<p>현대 클라우드 시스템(Google, Amazon, Microsoft)은 수천 개의 분산 컴포넌트로 구성되며, 하루에도 수백만 줄의 로그를 생성한다. 전통적으로 시스템 장애 발생 시 <strong>숙련된 운영자가 로그 파일을 직접 읽으며</strong> 문제를 진단했지만, 이제는:</p>
<ul>
<li><strong>규모의 폭발:</strong> 로그 양이 너무 많아 사람이 전부 읽는 것이 불가능</li>
<li><strong>복잡도 증가:</strong> 여러 회사/팀이 개발한 컴포넌트가 섞여 단일 전문가가 전체를 이해할 수 없음</li>
<li><strong>실시간성 요구:</strong> 문제 발생 즉시 탐지해야 하나 수동 검사는 너무 느림</li>
</ul>
<h4 id="기존-접근법의-한계">기존 접근법의 한계<a hidden class="anchor" aria-hidden="true" href="#기존-접근법의-한계">#</a></h4>
<table>
  <thead>
      <tr>
          <th>접근법</th>
          <th>내용</th>
          <th>한계</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>규칙 기반 도구</strong></td>
          <td>SEC, Logsurfer, Swatch 등 전문가가 수동으로 규칙 정의</td>
          <td>규칙 작성에 막대한 비용, 시스템 업데이트 시마다 재작성 필요</td>
      </tr>
      <tr>
          <td><strong>통계 학습 기반</strong></td>
          <td>PCA, SVM, 클러스터링으로 이상 패턴 탐지</td>
          <td>블랙박스 모델 - 이상을 탐지해도 &ldquo;왜 이상인지&rdquo; 설명 불가</td>
      </tr>
  </tbody>
</table>
<p><strong>핵심 문제의식:</strong><br>
기존 방법들은 이상을 탐지하더라도 <strong>운영자가 이해하기 어려운</strong> 결과를 제공한다. SOC 분석가는 &ldquo;뭔가 이상하다&quot;는 알림만 받고, 근본 원인을 찾기 위해 다시 수동 분석을 해야 한다.</p>
<hr>
<h3 id="2-핵심-개념-프로그램-불변성-program-invariants">2. 핵심 개념: 프로그램 불변성 (Program Invariants)<a hidden class="anchor" aria-hidden="true" href="#2-핵심-개념-프로그램-불변성-program-invariants">#</a></h3>
<h4 id="불변성이란">불변성이란?<a hidden class="anchor" aria-hidden="true" href="#불변성이란">#</a></h4>
<p><strong>&ldquo;서로 다른 입력과 워크로드 하에서도 항상 같은 값을 유지하는 조건&rdquo;</strong></p>
<p>일상적인 예시로 이해하기:</p>
<pre tabindex="0"><code>정상적인 파일 시스템에서는 항상:
&#34;파일 열기(Open)&#34; 로그 수 = &#34;파일 닫기(Close)&#34; 로그 수
</code></pre><p>만약 이 등식이 깨진다면? → <strong>파일 핸들러 누수(File Handler Leak)</strong> 의심!</p>
<h4 id="로그에서의-불변성-실행-흐름-불변성-execution-flow-invariants">로그에서의 불변성: 실행 흐름 불변성 (Execution Flow Invariants)<a hidden class="anchor" aria-hidden="true" href="#로그에서의-불변성-실행-흐름-불변성-execution-flow-invariants">#</a></h4>
<p>논문의 핵심 아이디어는 <strong>로그 메시지 개수 간의 선형 관계</strong>에서 불변성을 찾는 것이다.</p>
<p><strong>예시: 단순한 프로그램 실행 흐름</strong></p>
<pre tabindex="0"><code>     A (시작)
     ↓
     B (작업 분기)
    / \
   C   D (선택적 실행)
    \ /
     E (종료)
</code></pre><p>각 단계에서 로그를 남긴다면, 다음 <strong>불변 관계</strong>가 성립:</p>
<ol>
<li><code>c(A) = c(B) = c(E)</code> → 시작한 작업은 반드시 종료됨</li>
<li><code>c(B) = c(C) + c(D)</code> → B 이후 C 또는 D 중 하나는 실행됨</li>
</ol>
<p>여기서 <code>c(X)</code>는 로그 메시지 X의 개수.</p>
<p><strong>핵심:</strong> 이 관계는:</p>
<ul>
<li>워크로드가 달라져도 유지됨</li>
<li>여러 인스턴스의 로그가 섞여도(interleaved) 유지됨</li>
<li><strong>사람이 직관적으로 이해 가능</strong></li>
</ul>
<hr>
<h3 id="3-이론적-기반-왜-선형-불변성인가">3. 이론적 기반: 왜 선형 불변성인가?<a hidden class="anchor" aria-hidden="true" href="#3-이론적-기반-왜-선형-불변성인가">#</a></h3>
<h4 id="선형-불변성에-집중하는-두-가지-이유">선형 불변성에 집중하는 두 가지 이유:<a hidden class="anchor" aria-hidden="true" href="#선형-불변성에-집중하는-두-가지-이유">#</a></h4>
<table>
  <thead>
      <tr>
          <th>이유</th>
          <th>설명</th>
          <th>SOC 맥락에서의 의미</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>물리적 의미 명확성</strong></td>
          <td>선형 관계는 실행 경로의 특성을 직접 반영</td>
          <td>SOC 분석가가 &ldquo;왜 이상인지&rdquo; 즉시 이해 가능</td>
      </tr>
      <tr>
          <td><strong>이상 = 실행 경로 변화</strong></td>
          <td>대부분의 버그/공격은 정상과 다른 실행 흐름 유발</td>
          <td>불변성 위반 = 비정상 실행 경로 = 탐지</td>
      </tr>
  </tbody>
</table>
<h4 id="블랙박스-vs-화이트박스-비교">블랙박스 vs 화이트박스 비교<a hidden class="anchor" aria-hidden="true" href="#블랙박스-vs-화이트박스-비교">#</a></h4>
<table>
  <thead>
      <tr>
          <th>특성</th>
          <th>통계 모델 (PCA, SVM)</th>
          <th>불변성 기반</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>탐지 정확도</strong></td>
          <td>고차원 공간에서 이상 탐지</td>
          <td>선형 관계 위반만 탐지</td>
      </tr>
      <tr>
          <td><strong>해석 가능성</strong></td>
          <td>&ldquo;차원 3번이 임계값 초과&rdquo;</td>
          <td>&ldquo;파일 열기/닫기 수 불일치&rdquo;</td>
      </tr>
      <tr>
          <td><strong>근본 원인 추적</strong></td>
          <td>추가 분석 필요</td>
          <td>어떤 실행 흐름이 깨졌는지 직접 표시</td>
      </tr>
  </tbody>
</table>
<p><strong>예시:</strong></p>
<ul>
<li><strong>PCA 탐지 결과:</strong> &ldquo;주성분 3의 값이 3σ 벗어남&rdquo;</li>
<li><strong>불변성 탐지 결과:</strong> &ldquo;TaskTracker 시작 로그는 100개인데 종료 로그는 95개 - 5개 작업이 좀비 프로세스로 남음&rdquo;</li>
</ul>
<p>→ 어느 것이 SOC 분석가에게 더 유용한가?</p>
<hr>
<h3 id="4-연구의-핵심-기여">4. 연구의 핵심 기여<a hidden class="anchor" aria-hidden="true" href="#4-연구의-핵심-기여">#</a></h3>
<h4 id="a-자동-불변성-발견-알고리즘">A. 자동 불변성 발견 알고리즘<a hidden class="anchor" aria-hidden="true" href="#a-자동-불변성-발견-알고리즘">#</a></h4>
<p>기존 규칙 기반 방법은 <strong>사람이 직접</strong> 규칙을 작성해야 했다. 이 논문은:</p>
<ol>
<li><strong>비정형 로그 → 구조화:</strong> 로그 파서로 메시지 유형과 파라미터 분리</li>
<li><strong>파라미터 그룹핑:</strong> 같은 프로그램 변수에서 나온 파라미터 자동 식별</li>
<li><strong>선형 관계 자동 발견:</strong> 통계적 가설 검증으로 불변성 추출</li>
</ol>
<p><strong>의미:</strong> 전문가 없이도 시스템이 스스로 &ldquo;정상 동작의 법칙&quot;을 학습</p>
<h4 id="b-희소하고-정수-기반의-불변성-sparse-and-integer-invariants">B. 희소하고 정수 기반의 불변성 (Sparse and Integer Invariants)<a hidden class="anchor" aria-hidden="true" href="#b-희소하고-정수-기반의-불변성-sparse-and-integer-invariants">#</a></h4>
<p>모든 가능한 선형 관계를 찾는 게 아니라:</p>
<ul>
<li><strong>희소(Sparse):</strong> 소수의 핵심 로그 유형만 포함 → 해석 용이</li>
<li><strong>정수(Integer):</strong> 계수가 정수 → 물리적 의미 명확 (예: 1:1 관계, 2:1 관계)</li>
</ul>
<p><strong>예시:</strong></p>
<ul>
<li>나쁜 예: <code>0.73 * c(A) + 1.42 * c(B) - 0.91 * c(C) = 0</code> (복잡, 의미 불명)</li>
<li>좋은 예: <code>c(A) = c(B) + c(C)</code> (단순, 명확)</li>
</ul>
<h4 id="c-확장-가능성">C. 확장 가능성<a hidden class="anchor" aria-hidden="true" href="#c-확장-가능성">#</a></h4>
<ul>
<li>Hadoop 같은 대규모 분산 시스템에 적용 가능</li>
<li>로그 인터리빙(여러 작업의 로그 섞임) 문제 해결</li>
<li>계산 복잡도 최적화 기법 제시</li>
</ul>
<hr>
<h3 id="5-soc-관점-인사이트-soc-perspective-insight">5. SOC 관점 인사이트 (SOC Perspective Insight)<a hidden class="anchor" aria-hidden="true" href="#5-soc-관점-인사이트-soc-perspective-insight">#</a></h3>
<h4 id="deeplog과의-비교-관점">DeepLog과의 비교 관점<a hidden class="anchor" aria-hidden="true" href="#deeplog과의-비교-관점">#</a></h4>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>DeepLog (2017)</th>
          <th>Invariants Mining (2010)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>탐지 원리</strong></td>
          <td>LSTM으로 다음 로그 예측</td>
          <td>선형 불변성 위반 검사</td>
      </tr>
      <tr>
          <td><strong>해석 가능성</strong></td>
          <td>블랙박스</td>
          <td>화이트박스</td>
      </tr>
      <tr>
          <td><strong>학습 데이터</strong></td>
          <td>대량의 정상 로그 필요</td>
          <td>상대적으로 적은 데이터로 가능</td>
      </tr>
      <tr>
          <td><strong>적용 시점</strong></td>
          <td>패턴이 복잡한 경우</td>
          <td>실행 흐름이 명확한 경우</td>
      </tr>
  </tbody>
</table>
<h4 id="soc-실무-적용-초기-아이디어">SOC 실무 적용 초기 아이디어<a hidden class="anchor" aria-hidden="true" href="#soc-실무-적용-초기-아이디어">#</a></h4>
<p><strong>언제 불변성 기반을 쓸 것인가?</strong></p>
<ul>
<li>시스템 실행 흐름이 비교적 <strong>명확하고 안정적</strong>인 경우</li>
<li>이상 탐지뿐 아니라 <strong>근본 원인 분석</strong>까지 필요한 경우</li>
<li>SOC 분석가가 결과를 <strong>직접 이해하고 설명</strong>해야 하는 상황</li>
</ul>
<p><strong>언제 DeepLog을 쓸 것인가?</strong></p>
<ul>
<li>실행 흐름이 너무 복잡해 선형 관계로 표현 불가능한 경우</li>
<li>대량의 학습 데이터가 확보된 경우</li>
<li>높은 탐지율이 해석 가능성보다 중요한 경우</li>
</ul>
<p><strong>실무 전략:</strong> 두 방법을 <strong>병행</strong>하는 하이브리드 접근</p>
<ol>
<li>1차 필터: 불변성 기반으로 명확한 이상 먼저 탐지 + 자동 설명</li>
<li>2차 분석: DeepLog으로 미묘한 패턴 이상 탐지</li>
<li>3차 검증: 분석가가 불변성 위반 내역 참고하여 DeepLog 결과 해석</li>
</ol>
<hr>
<h3 id="6-개인-인사이트-personal-insight">6. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#6-개인-인사이트-personal-insight">#</a></h3>
<p><strong>Day 1을 읽고 느낀 점:</strong></p>
<p>이 논문이 2010년에 나왔다는 게 놀랍다. DeepLog보다 7년 빠른데도 <strong>&ldquo;해석 가능성&rdquo;</strong> 이라는 핵심 문제를 정확히 짚었다.</p>
<p>SOC 분석가 입장에서는:</p>
<ul>
<li>&ldquo;뭔가 이상하다&quot;는 알림보다</li>
<li><strong>&ldquo;어떤 실행 흐름이 깨졌는지&rdquo;</strong> 알려주는 게 훨씬 실용적</li>
</ul>
<p>특히 &ldquo;파일 열기 100개, 닫기 95개 → 5개 핸들러 누수 의심&rdquo; 같은 직관적인 정보는 즉시 대응으로 이어질 수 있다.</p>
<p><strong>DeepLog과의 대비:</strong></p>
<ul>
<li>DeepLog: &ldquo;이 로그 시퀀스는 95% 확률로 이상입니다&rdquo;</li>
<li>Invariants: &ldquo;시작 로그 100개, 종료 로그 95개 - 5개 작업이 정리 안 됨&rdquo;</li>
</ul>
<p>→ 실무에서는 후자가 더 actionable하다.</p>
<p><strong>다음 궁금증 (Day 2 Preview):</strong>
그렇다면 이 &ldquo;불변성&quot;을 어떻게 <strong>자동으로</strong> 찾아내는가? 모든 가능한 선형 조합을 다 시도하면 계산 폭발하지 않나? 알고리즘이 궁금하다.</p>
<hr>
<h1 id="research-review-mining-invariants-from-console-logs-for-system-problem-detection-1">Research Review: Mining Invariants from Console Logs for System Problem Detection<a hidden class="anchor" aria-hidden="true" href="#research-review-mining-invariants-from-console-logs-for-system-problem-detection-1">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2024.12.23<br>
<strong>Keywords:</strong> Log_Invariants, Anomaly_Detection, Execution_Flow, Linear_Relationships, Rule_Mining<br>
<strong>Source:</strong> USENIX ATC 2010 <a href="https://www.usenix.org/legacy/events/atc10/tech/full_papers/Lou.pdf">Paper Link</a></p>
</blockquote>
<hr>
<h2 id="day-2--research-model-hypotheses-and-methodology">Day 2 – Research Model, Hypotheses, and Methodology<a hidden class="anchor" aria-hidden="true" href="#day-2--research-model-hypotheses-and-methodology">#</a></h2>
<p><em>(불변성을 어떻게 자동으로 찾아내는가)</em></p>
<h3 id="1-연구-모델-개요">1. 연구 모델 개요<a hidden class="anchor" aria-hidden="true" href="#1-연구-모델-개요">#</a></h3>
<p>이 논문의 핵심은 <strong>4단계 파이프라인</strong>으로 구성된다:</p>
<pre tabindex="0"><code>[비정형 로그] 
    ↓ (1) Log Parsing
[구조화 로그: 시그니처 + 파라미터]
    ↓ (2) Log Message Grouping
[메시지 카운트 벡터]
    ↓ (3) Invariant Mining
[불변성 집합]
    ↓ (4) Anomaly Detection
[이상 탐지 결과]
</code></pre><p>각 단계를 자세히 살펴보자.</p>
<hr>
<h3 id="2-불변성의-수학적-표현">2. 불변성의 수학적 표현<a hidden class="anchor" aria-hidden="true" href="#2-불변성의-수학적-표현">#</a></h3>
<h4 id="a-선형-방정식으로서의-불변성">A. 선형 방정식으로서의 불변성<a hidden class="anchor" aria-hidden="true" href="#a-선형-방정식으로서의-불변성">#</a></h4>
<p><strong>핵심 아이디어:</strong> 불변성은 로그 메시지 개수 간의 선형 방정식으로 표현된다.</p>
<p>m개의 로그 메시지 유형이 있을 때, 불변성은 다음과 같이 표현:</p>
<pre tabindex="0"><code>a₀ + a₁x₁ + a₂x₂ + ... + aₘxₘ = 0
</code></pre><p>여기서:</p>
<ul>
<li><code>xⱼ</code>: j번째 로그 메시지 유형의 개수</li>
<li><code>θ = [a₀, a₁, ..., aₘ]ᵀ</code>: 불변성 벡터 (계수들)</li>
</ul>
<p><strong>예시:</strong> Day 1의 <code>c(B) = c(C) + c(D)</code> 는:</p>
<ul>
<li>벡터 표현: <code>θ = [0, 0, 1, -1, -1, 0]ᵀ</code></li>
<li>의미: B 메시지 1개 = C 메시지 1개 + D 메시지 1개</li>
</ul>
<h4 id="b-행렬-형태로-확장">B. 행렬 형태로 확장<a hidden class="anchor" aria-hidden="true" href="#b-행렬-형태로-확장">#</a></h4>
<p>n개의 과거 로그 시퀀스가 있을 때, 메시지 카운트 행렬 X:</p>
<pre tabindex="0"><code>X = [1  x₁₁  x₁₂  ...  x₁ₘ]
    [1  x₂₁  x₂₂  ...  x₂ₘ]
    [⋮   ⋮    ⋮   ⋱    ⋮  ]
    [1  xₙ₁  xₙ₂  ...  xₙₘ]
</code></pre><p>모든 정상 로그가 불변성을 만족한다면:</p>
<pre tabindex="0"><code>Xθ = 0
</code></pre><p><strong>핵심 통찰:</strong> 불변성 벡터 θ는 행렬 X의 <strong>영공간(Null Space)</strong> 에 속한다!</p>
<h4 id="c-불변성-공간-invariant-space">C. 불변성 공간 (Invariant Space)<a hidden class="anchor" aria-hidden="true" href="#c-불변성-공간-invariant-space">#</a></h4>
<table>
  <thead>
      <tr>
          <th>개념</th>
          <th>정의</th>
          <th>의미</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Row Space</strong></td>
          <td>X의 행벡터들이 생성하는 공간</td>
          <td>실제 관찰된 로그 패턴들</td>
      </tr>
      <tr>
          <td><strong>Null Space</strong></td>
          <td>Xθ = 0을 만족하는 모든 θ의 공간</td>
          <td>가능한 모든 불변성들</td>
      </tr>
      <tr>
          <td><strong>Invariant Space</strong></td>
          <td>X의 Null Space</td>
          <td>프로그램의 불변성 공간</td>
      </tr>
  </tbody>
</table>
<p><strong>중요:</strong> 영공간의 모든 벡터가 불변성이지만, 의미 있는 불변성을 찾으려면 <strong>희소성(Sparseness)</strong> 과 <strong>정수 제약(Integer Constraint)</strong> 이 필요!</p>
<hr>
<h3 id="3-연구-방법론-4단계-파이프라인">3. 연구 방법론: 4단계 파이프라인<a hidden class="anchor" aria-hidden="true" href="#3-연구-방법론-4단계-파이프라인">#</a></h3>
<h3 id="step-1-로그-파싱-log-parsing">Step 1: 로그 파싱 (Log Parsing)<a hidden class="anchor" aria-hidden="true" href="#step-1-로그-파싱-log-parsing">#</a></h3>
<h4 id="목표">목표<a hidden class="anchor" aria-hidden="true" href="#목표">#</a></h4>
<p>비정형 텍스트 로그를 구조화된 형태로 변환</p>
<p><strong>입력 예시:</strong></p>
<pre tabindex="0"><code>New job added to schedule, jobid = 8821, priority = 64
</code></pre><p><strong>출력 형태:</strong></p>
<pre tabindex="0"><code>Signature: &#34;New job added to schedule, jobid=[], priority=[]&#34;
Parameters: [8821, 64]
</code></pre><h4 id="변환-과정">변환 과정<a hidden class="anchor" aria-hidden="true" href="#변환-과정">#</a></h4>
<table>
  <thead>
      <tr>
          <th>요소</th>
          <th>설명</th>
          <th>추출 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Message Signature</strong></td>
          <td>로그 타입을 나타내는 상수 텍스트</td>
          <td>같은 log-print 문에서 나온 메시지들의 공통 부분</td>
      </tr>
      <tr>
          <td><strong>Parameter Values</strong></td>
          <td>실행마다 변하는 변수 값들</td>
          <td>숫자, ID 등 가변적인 부분</td>
      </tr>
      <tr>
          <td><strong>Timestamp</strong></td>
          <td>로그 발생 시간</td>
          <td>로그 시작 부분의 시간 정보</td>
      </tr>
  </tbody>
</table>
<p><strong>튜플 표현:</strong></p>
<pre tabindex="0"><code>(Timestamp, Signature, [Param1, Param2, ...])
</code></pre><p><strong>논문의 파싱 방법:</strong></p>
<ul>
<li>소스 코드가 있으면: 코드 기반 파싱 (높은 정확도)</li>
<li>소스 코드 없으면: 자동 패턴 인식 알고리즘 [논문 저자의 이전 연구, 95% 정확도]</li>
</ul>
<hr>
<h3 id="step-2-로그-메시지-그룹핑-log-message-grouping">Step 2: 로그 메시지 그룹핑 (Log Message Grouping)<a hidden class="anchor" aria-hidden="true" href="#step-2-로그-메시지-그룹핑-log-message-grouping">#</a></h3>
<h4 id="핵심-아이디어-cogenetic-parameters-동원-파라미터">핵심 아이디어: Cogenetic Parameters (동원 파라미터)<a hidden class="anchor" aria-hidden="true" href="#핵심-아이디어-cogenetic-parameters-동원-파라미터">#</a></h4>
<p><strong>문제:</strong> 같은 프로그램 변수가 여러 로그 문장에서 다른 파라미터로 나타날 수 있다.</p>
<p><strong>예시:</strong></p>
<pre tabindex="0"><code>Log A: &#34;Request received, reqID = 12345&#34;
Log B: &#34;Processing request, requestID = 12345&#34;
Log C: &#34;Request completed, req = 12345&#34;
</code></pre><p>→ 세 파라미터(reqID, requestID, req)는 실제로는 <strong>같은 변수</strong>!</p>
<h4 id="cogenetic-parameters-판별-알고리즘">Cogenetic Parameters 판별 알고리즘<a hidden class="anchor" aria-hidden="true" href="#cogenetic-parameters-판별-알고리즘">#</a></h4>
<p><strong>Algorithm 1: Log Parameter Grouping</strong></p>
<p><strong>Step 1:</strong> 각 파라미터의 값 범위(Value Range) 계산</p>
<ul>
<li>각 로그 묶음(log bunch)에서 파라미터의 모든 고유 값 추출</li>
<li>예: Pa의 값 범위 Vr(Pa) = {12345, 67890, &hellip;}</li>
</ul>
<p><strong>Step 2:</strong> 두 파라미터가 동원인지 판별</p>
<p>두 파라미터 Pa와 Pb가 동원이려면:</p>
<table>
  <thead>
      <tr>
          <th>조건</th>
          <th>설명</th>
          <th>이유</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>부분집합 관계</strong></td>
          <td>모든 로그 묶음에서 Vr(Pa) ⊆ Vr(Pb) 또는 반대</td>
          <td>같은 변수면 값 범위가 겹침</td>
      </tr>
      <tr>
          <td><strong>충분한 값 개수</strong></td>
          <td>min(|Vr(Pa)|, |Vr(Pb)|) ≥ 10</td>
          <td>우연의 일치 방지</td>
      </tr>
      <tr>
          <td><strong>충분한 값 길이</strong></td>
          <td>각 값이 최소 3글자 이상</td>
          <td>짧은 값(1, 2)은 우연히 겹칠 수 있음</td>
      </tr>
  </tbody>
</table>
<p><strong>Step 3:</strong> 동원 파라미터 그룹 형성</p>
<ul>
<li>Pa ≅ Pb 이고 Pa ≅ Pc 이면 → Pa, Pb, Pc는 모두 동원</li>
<li>전이적 관계(transitive)를 이용해 그룹 확장</li>
</ul>
<p><strong>결과:</strong> 각 그룹 = 하나의 프로그램 변수</p>
<h4 id="메시지-그룹-생성">메시지 그룹 생성<a hidden class="anchor" aria-hidden="true" href="#메시지-그룹-생성">#</a></h4>
<p>동원 파라미터 그룹 A에 대해:</p>
<ul>
<li>A에 속한 파라미터를 포함하는 로그들 중</li>
<li><strong>파라미터 값이 모두 같은</strong> 로그들을 하나의 그룹으로 묶음</li>
</ul>
<p><strong>예시:</strong></p>
<pre tabindex="0"><code>동원 그룹: {reqID, requestID, req}
값 = 12345인 로그들 → 그룹 1
값 = 67890인 로그들 → 그룹 2
</code></pre><p>각 그룹 = <strong>하나의 실행 경로</strong>(예: 특정 요청 처리 과정)</p>
<h4 id="메시지-카운트-벡터-생성">메시지 카운트 벡터 생성<a hidden class="anchor" aria-hidden="true" href="#메시지-카운트-벡터-생성">#</a></h4>
<p>각 메시지 그룹에서:</p>
<ul>
<li>각 메시지 타입(signature)이 몇 개 나타났는지 계산</li>
<li>벡터 형태로 표현</li>
</ul>
<p><strong>예시:</strong></p>
<pre tabindex="0"><code>그룹 1: [시그니처A: 5개, 시그니처B: 5개, 시그니처C: 3개, 시그니처D: 2개]
→ 카운트 벡터: [5, 5, 3, 2]
</code></pre><p>이렇게 모든 그룹의 카운트 벡터를 모으면 → <strong>행렬 X 완성</strong>!</p>
<hr>
<h3 id="step-3-불변성-마이닝-invariant-mining">Step 3: 불변성 마이닝 (Invariant Mining)<a hidden class="anchor" aria-hidden="true" href="#step-3-불변성-마이닝-invariant-mining">#</a></h3>
<h4 id="목표-1">목표<a hidden class="anchor" aria-hidden="true" href="#목표-1">#</a></h4>
<p>행렬 X로부터 <strong>희소하고 정수 계수를 가진 불변성</strong>을 자동으로 찾기</p>
<h4 id="a-왜-희소성sparseness인가">A. 왜 희소성(Sparseness)인가?<a hidden class="anchor" aria-hidden="true" href="#a-왜-희소성sparseness인가">#</a></h4>
<p><strong>문제:</strong> 영공간의 모든 벡터가 불변성이지만, 대부분은 의미 없음</p>
<p><strong>예시:</strong></p>
<ul>
<li>의미 있는 불변성: <code>c(A) = c(B) + c(C)</code> (3개 항만 포함)</li>
<li>의미 없는 불변성: <code>0.73c(A) + 1.42c(B) - 0.91c(C) + ... (수십 개 항)</code></li>
</ul>
<p><strong>핵심 통찰:</strong></p>
<ul>
<li>프로그램의 <strong>기본 실행 구조</strong>(순차, 분기, 합류)는 단순함</li>
<li>단순한 구조 = 적은 수의 로그 타입만 관련됨</li>
<li>따라서 기본 불변성은 <strong>희소</strong>(sparse)해야 함</li>
</ul>
<p><strong>희소성 정의:</strong></p>
<ul>
<li>영이 아닌 계수의 개수가 K_X 이하</li>
<li>K_X = m + 1 - r (m: 메시지 타입 수, r: 불변성 공간 차원)</li>
<li>실제로 K_X는 보통 3~4 정도로 작음</li>
</ul>
<h4 id="b-왜-정수-제약integer-constraint인가">B. 왜 정수 제약(Integer Constraint)인가?<a hidden class="anchor" aria-hidden="true" href="#b-왜-정수-제약integer-constraint인가">#</a></h4>
<p><strong>이유:</strong></p>
<ol>
<li>
<p><strong>물리적 의미:</strong> 순차/분기/합류 구조는 정수 비율로 표현됨</p>
<ul>
<li>1:1 관계 (순차): <code>c(A) = c(B)</code></li>
<li>1:2 관계 (복제): <code>c(A) = 2*c(B)</code></li>
<li>합 관계 (분기): <code>c(A) = c(B) + c(C)</code></li>
</ul>
</li>
<li>
<p><strong>해석 용이성:</strong> 정수 계수는 사람이 이해하기 쉬움</p>
<ul>
<li>좋은 예: <code>[0, 1, -1, -1, 0]</code> → &ldquo;B = C + D&rdquo;</li>
<li>나쁜 예: <code>[0.17, 0.73, -0.91, -1.22, 0.03]</code> → &ldquo;???&rdquo;</li>
</ul>
</li>
</ol>
<h4 id="c-compact-invariant-set-간결한-불변성-집합">C. Compact Invariant Set (간결한 불변성 집합)<a hidden class="anchor" aria-hidden="true" href="#c-compact-invariant-set-간결한-불변성-집합">#</a></h4>
<p><strong>중복성 문제:</strong></p>
<pre tabindex="0"><code>{c(A) = c(B), c(A) = c(E), c(E) = c(B)}
</code></pre><p>→ 세 번째는 앞의 두 개로부터 유도 가능 (중복!)</p>
<p><strong>Compact Set 정의:</strong></p>
<ul>
<li>어떤 불변성도 나머지 불변성들의 선형 결합이 아님</li>
<li>최대 r개의 불변성만 포함 (r = 불변성 공간 차원)</li>
</ul>
<p><strong>목표:</strong>
<strong>가장 큰 간결한 희소 정수 불변성 집합</strong> 찾기!</p>
<h4 id="d-불변성-탐색-알고리즘">D. 불변성 탐색 알고리즘<a hidden class="anchor" aria-hidden="true" href="#d-불변성-탐색-알고리즘">#</a></h4>
<p><strong>Challenge:</strong> 희소 불변성 찾기는 NP-Hard 문제!</p>
<p><strong>전략 1: 영공간 추정 (SVD 사용)</strong></p>
<pre tabindex="0"><code>1. 행렬 X에 대해 SVD 수행: X = UΛVᵀ
2. 작은 특이값에 해당하는 오른쪽 특이벡터들 검증
3. 지지율(Support Ratio) 계산:
   - 지지율 = 불변성을 만족하는 메시지 그룹 비율
   - 98% 이상이면 유효한 불변성
4. 유효한 벡터들의 span = 불변성 공간
</code></pre><p><strong>전략 2: 가설 검증 프레임워크 (Hypothesis Testing)</strong></p>
<p><strong>핵심 아이디어:</strong>
&ldquo;k개의 특정 메시지 타입만 관련된 불변성이 있는가?&ldquo;를 체계적으로 검증</p>
<p><strong>Algorithm 2: Mining Invariants</strong></p>
<pre tabindex="0"><code>Input: 메시지 카운트 행렬 X (n × (m+1))
Output: 간결한 희소 정수 불변성 집합

1. SVD로 불변성 공간 차원 r 추정

2. Brute Force 탐색 (k = 1 ~ 5):
   For k = 1 to 5:
       For 모든 k개 메시지 타입 조합:
           2.1) 부분 행렬 X&#39; 생성 (k개 열만)
           2.2) 후보 벡터 θ&#39; = argmin ||X&#39;θ&#39;||₂
           2.3) θ&#39;를 정수화 (l = 1, 2, 3 시도)
           2.4) 지지율 계산
           2.5) 지지율 ≥ 98%면 유효한 불변성 추가
   
   종료 조건:
   - r개의 독립 불변성을 찾음, 또는
   - k &gt; (m - r + 1)

3. (Optional) Greedy 탐색 (k &gt; 5):
   탐욕 알고리즘으로 추가 불변성 탐색
</code></pre><p><strong>정수화 과정 예시:</strong></p>
<pre tabindex="0"><code>1. θ&#39; = [0, 0.33, -0.67, 0] (실수 후보)
2. 최소 비제로 계수 0.33을 1로 스케일: × 3
3. θ = [0, 1, -2, 0] (정수 불변성!)
4. 의미: &#34;메시지2 개수 = 메시지3 개수 × 2&#34;
</code></pre><h4 id="e-계산-복잡도-최적화">E. 계산 복잡도 최적화<a hidden class="anchor" aria-hidden="true" href="#e-계산-복잡도-최적화">#</a></h4>
<p><strong>문제:</strong> 조합 폭발</p>
<ul>
<li>m개 메시지 타입에서 k개 선택: C(m, k)</li>
<li>예: m=28, k=4 → 20,475가지!</li>
</ul>
<p><strong>최적화 기법들:</strong></p>
<table>
  <thead>
      <tr>
          <th>기법</th>
          <th>설명</th>
          <th>효과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>메시지 그룹핑</strong></td>
          <td>관련 있는 메시지만 함께 분석</td>
          <td>m 크기 대폭 감소</td>
      </tr>
      <tr>
          <td><strong>조기 종료</strong></td>
          <td>r개 찾으면 중단</td>
          <td>불필요한 탐색 회피</td>
      </tr>
      <tr>
          <td><strong>중복 건너뛰기</strong></td>
          <td>이미 찾은 불변성의 선형 결합은 탐색 안 함</td>
          <td>탐색 공간 대폭 축소</td>
      </tr>
      <tr>
          <td><strong>SVD 대신 EVD</strong></td>
          <td>XᵀX로 차원 축소 (m×m 행렬)</td>
          <td>대규모 데이터 처리 가능</td>
      </tr>
  </tbody>
</table>
<p><strong>실제 효과 (Hadoop 로그):</strong></p>
<pre tabindex="0"><code>MapTask Attempt ID 메시지 그룹:
- 원래 탐색 공간: 24,157
- 최적화 후: 3,310 (86% 감소!)
</code></pre><hr>
<h3 id="4-실무-도전과제-해결-방법">4. 실무 도전과제 해결 방법<a hidden class="anchor" aria-hidden="true" href="#4-실무-도전과제-해결-방법">#</a></h3>
<h4 id="도전과제-1-노이즈와-비정상-로그">도전과제 1: 노이즈와 비정상 로그<a hidden class="anchor" aria-hidden="true" href="#도전과제-1-노이즈와-비정상-로그">#</a></h4>
<p><strong>문제:</strong> 수집된 로그 중 일부는 실패나 노이즈 포함</p>
<p><strong>해결책:</strong> 지지율(Support Ratio) 개념</p>
<ul>
<li>98% 이상의 로그 그룹이 만족하면 유효한 불변성</li>
<li>2% 이하의 이상은 허용 (유연성)</li>
</ul>
<h4 id="도전과제-2-부분-로그-시퀀스">도전과제 2: 부분 로그 시퀀스<a hidden class="anchor" aria-hidden="true" href="#도전과제-2-부분-로그-시퀀스">#</a></h4>
<p><strong>문제:</strong> 지속적으로 실행되는 시스템에서 로그를 중간에 잘라서 수집</p>
<p><strong>해결책:</strong></p>
<ul>
<li>파라미터 그룹핑으로 완전한 실행 경로만 분석</li>
<li>불완전한 그룹은 지지율 계산에서 자연스럽게 제외</li>
</ul>
<h4 id="도전과제-3-로그-인터리빙">도전과제 3: 로그 인터리빙<a hidden class="anchor" aria-hidden="true" href="#도전과제-3-로그-인터리빙">#</a></h4>
<p><strong>문제:</strong> 여러 작업의 로그가 섞여있음</p>
<p><strong>해결책:</strong></p>
<ul>
<li>FSA(Finite State Automaton) 방법은 인터리빙에 취약</li>
<li>이 논문의 방법은 <strong>메시지 개수만</strong> 사용하므로 순서 무관!</li>
<li>인터리빙에 영향받지 않음</li>
</ul>
<hr>
<h3 id="5-soc-관점-인사이트">5. SOC 관점 인사이트<a hidden class="anchor" aria-hidden="true" href="#5-soc-관점-인사이트">#</a></h3>
<h4 id="a-deeplog과의-방법론-비교">A. DeepLog과의 방법론 비교<a hidden class="anchor" aria-hidden="true" href="#a-deeplog과의-방법론-비교">#</a></h4>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>DeepLog</th>
          <th>Invariants Mining</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>사전 지식 필요</strong></td>
          <td>없음 (end-to-end 학습)</td>
          <td>파라미터 그룹핑 필요</td>
      </tr>
      <tr>
          <td><strong>계산 복잡도</strong></td>
          <td>O(학습 반복수 × 데이터 크기)</td>
          <td>NP-Hard지만 최적화 가능</td>
      </tr>
      <tr>
          <td><strong>설명 가능성</strong></td>
          <td>없음 (블랙박스)</td>
          <td>명확한 선형 관계</td>
      </tr>
      <tr>
          <td><strong>인터리빙 대응</strong></td>
          <td>시퀀스 순서 중요</td>
          <td>개수만 보므로 순서 무관</td>
      </tr>
  </tbody>
</table>
<h4 id="b-soc-실무-적용-시사점">B. SOC 실무 적용 시사점<a hidden class="anchor" aria-hidden="true" href="#b-soc-실무-적용-시사점">#</a></h4>
<p><strong>언제 이 방법을 쓸 것인가:</strong></p>
<ol>
<li>
<p><strong>시스템이 명확한 실행 흐름을 가질 때</strong></p>
<ul>
<li>예: 워크플로우 엔진, ETL 파이프라인</li>
<li>비례: 웹 서버 로그 (요청-처리-응답)</li>
</ul>
</li>
<li>
<p><strong>로그에 프로그램 변수(ID) 포함 시</strong></p>
<ul>
<li>예: 요청ID, 작업ID, 세션ID</li>
<li>반례: 단순 에러 메시지만 있는 경우</li>
</ul>
</li>
<li>
<p><strong>근본 원인 분석이 중요할 때</strong></p>
<ul>
<li>SOC 티켓: &ldquo;TaskTracker 시작 100, 종료 95&rdquo;</li>
<li>→ 즉시 5개 좀비 프로세스 문제로 인식</li>
</ul>
</li>
</ol>
<p><strong>실무 체크리스트:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 로그에 요청ID/작업ID 같은 식별자 포함되는가?</li>
<li><input disabled="" type="checkbox"> 시스템 실행 흐름이 비교적 예측 가능한가?</li>
<li><input disabled="" type="checkbox"> 분석가가 탐지 이유를 설명해야 하는가?</li>
<li><input disabled="" type="checkbox"> 로그가 여러 작업에서 섞여 나오는가? (인터리빙)</li>
</ul>
<p>4개 중 3개 이상 Yes → 이 방법 고려!</p>
<hr>
<h3 id="6-개인-인사이트-personal-insight-1">6. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#6-개인-인사이트-personal-insight-1">#</a></h3>
<p><strong>Day 2를 읽고 느낀 점:</strong></p>
<p><strong>1. 수학적 우아함</strong>
불변성을 &ldquo;영공간의 벡터&quot;로 정의한 것이 정말 깔끔하다. Xθ = 0 라는 하나의 방정식이 모든 것을 설명한다.</p>
<p><strong>2. 실용성과 이론의 균형</strong></p>
<ul>
<li>이론: NP-Hard 문제라는 것을 명확히 인식</li>
<li>실용: 실제 시스템에서 m-r이 작다는 관찰로 해결 가능함을 증명</li>
</ul>
<p><strong>3. Cogenetic Parameters의 독창성</strong>
&ldquo;같은 변수를 자동으로 찾기&quot;는 정말 어려운 문제인데, 값 범위 비교라는 간단한 휴리스틱으로 해결. 이런 실용적 접근이 인상적이다.</p>
<p><strong>4. DeepLog 대비 장단점 명확화</strong></p>
<p><strong>장점:</strong></p>
<ul>
<li>인터리빙 문제 자연스럽게 해결 (순서 무관)</li>
<li>설명 가능성 (SOC 분석가에게 핵심)</li>
<li>파라미터 기반 그룹핑으로 탐색 공간 축소</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>파라미터가 없는 로그에는 적용 불가</li>
<li>여전히 조합 최적화 문제의 근본적 어려움</li>
<li>비선형 관계는 못 찾음</li>
</ul>
<p><strong>5. SOC 실무 적용 전략</strong></p>
<p>실제 SOC에서는:</p>
<ol>
<li><strong>1차 필터:</strong> 이 방법으로 명확한 불변성 위반 탐지
<ul>
<li>예: &ldquo;시작 100, 종료 95&rdquo; → 즉시 대응</li>
</ul>
</li>
<li><strong>2차 분석:</strong> DeepLog으로 미묘한 패턴 이상 탐지
<ul>
<li>예: 정상 범위지만 비정상 시퀀스</li>
</ul>
</li>
<li><strong>하이브리드:</strong> 불변성 위반 정보를 DeepLog 학습에 활용
<ul>
<li>예: 불변성 위반한 로그는 negative sample로 사용</li>
</ul>
</li>
</ol>
<p><strong>다음 궁금증 (Day 3 Preview):</strong>
Hadoop에 실제로 적용하면 어떤 불변성을 찾았을까? 탐지율과 오탐율은? 실제 버그를 잡아냈나?</p>
<hr>
<p>완벽해! 이제 Day 3 정리할게!</p>
<hr>
<h1 id="research-review-mining-invariants-from-console-logs-for-system-problem-detection-2">Research Review: Mining Invariants from Console Logs for System Problem Detection<a hidden class="anchor" aria-hidden="true" href="#research-review-mining-invariants-from-console-logs-for-system-problem-detection-2">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2024.12.24<br>
<strong>Keywords:</strong> Log_Invariants, Anomaly_Detection, Execution_Flow, Linear_Relationships, Rule_Mining<br>
<strong>Source:</strong> USENIX ATC 2010 <a href="https://www.usenix.org/legacy/events/atc10/tech/full_papers/Lou.pdf">Paper Link</a></p>
</blockquote>
<hr>
<h2 id="day-3--empirical-results-and-hypothesis-testing">Day 3 – Empirical Results and Hypothesis Testing<a hidden class="anchor" aria-hidden="true" href="#day-3--empirical-results-and-hypothesis-testing">#</a></h2>
<p><em>(실제 시스템에서의 검증: Hadoop과 CloudDB 사례)</em></p>
<h3 id="1-이상-탐지-절차-anomaly-detection-process">1. 이상 탐지 절차 (Anomaly Detection Process)<a hidden class="anchor" aria-hidden="true" href="#1-이상-탐지-절차-anomaly-detection-process">#</a></h3>
<p>학습된 불변성으로 이상을 탐지하는 과정:</p>
<pre tabindex="0"><code>[새로운 로그 입력]
    ↓
1. 로그 파싱 (비정형 → 튜플 형식)
    ↓
2. 메시지 그룹핑 및 카운트 벡터 계산
    ↓
3. 각 카운트 벡터를 학습된 불변성과 비교
    ↓
4. 불변성 위반 검사
    ↓
[이상 탐지 + 위반된 불변성 정보 제공]
</code></pre><p><strong>핵심:</strong> 단순히 &ldquo;이상하다&quot;가 아니라 <strong>&ldquo;어떤 불변성을 위반했는지&rdquo;</strong> 함께 제공!</p>
<hr>
<h3 id="2-실험-설계-experimental-setup">2. 실험 설계 (Experimental Setup)<a hidden class="anchor" aria-hidden="true" href="#2-실험-설계-experimental-setup">#</a></h3>
<h4 id="a-hadoop-테스트베드">A. Hadoop 테스트베드<a hidden class="anchor" aria-hidden="true" href="#a-hadoop-테스트베드">#</a></h4>
<p><strong>시스템 구성:</strong></p>
<ul>
<li>Hadoop 버전 0.19 (MapReduce + HDFS)</li>
<li>마스터 1대 + 슬레이브 15대 (3가지 하드웨어 구성 혼합)</li>
<li>모두 1G 이더넷 스위치로 연결</li>
</ul>
<p><strong>워크로드:</strong></p>
<ul>
<li>WordCount: 텍스트 단어 빈도 계산</li>
<li>Sort: 숫자 정렬</li>
<li>실행 중 CPU/메모리 경쟁 유발 프로그램(CPUEater) 무작위 실행</li>
</ul>
<p><strong>로그 수집:</strong></p>
<ul>
<li>4개 시점에서 수집 (각각 하나의 log bunch)</li>
<li>총 약 2,400만 줄의 로그 메시지</li>
<li>최소 116MB ~ 최대 1.3GB per bunch</li>
</ul>
<p><strong>실험 전략:</strong></p>
<ul>
<li>능동적 에러 주입이 아닌 <strong>자원 경쟁으로 내재된 버그 노출</strong></li>
<li>실제 운영 환경과 유사한 조건</li>
</ul>
<h4 id="b-clouddb-테스트베드">B. CloudDB 테스트베드<a hidden class="anchor" aria-hidden="true" href="#b-clouddb-테스트베드">#</a></h4>
<p><strong>시스템 설명:</strong></p>
<ul>
<li>Microsoft 내부용 분산 데이터 스토리지 서비스</li>
<li>수만 대 서버로 확장 가능</li>
<li>자동 장애조치, 부하 분산, 파티셔닝 지원</li>
</ul>
<p><strong>실험 범위:</strong></p>
<ul>
<li>Fabric 및 CASNode 레벨 로그 분석</li>
<li>약 1,200만 줄의 로그 메시지</li>
<li>266개 불변성 학습</li>
</ul>
<hr>
<h3 id="3-hadoop-실험-결과">3. Hadoop 실험 결과<a hidden class="anchor" aria-hidden="true" href="#3-hadoop-실험-결과">#</a></h3>
<h4 id="a-파라미터-그룹핑-결과">A. 파라미터 그룹핑 결과<a hidden class="anchor" aria-hidden="true" href="#a-파라미터-그룹핑-결과">#</a></h4>
<p>알고리즘이 자동으로 발견한 의미 있는 프로그램 변수들:</p>
<table>
  <thead>
      <tr>
          <th>파라미터 그룹</th>
          <th>타입</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Map/Reduce Task ID</strong></td>
          <td>객체 식별자</td>
          <td>작업 추적</td>
      </tr>
      <tr>
          <td><strong>Map/Reduce Task Attempt ID</strong></td>
          <td>객체 식별자</td>
          <td>재시도 추적</td>
      </tr>
      <tr>
          <td><strong>Block ID</strong></td>
          <td>객체 식별자</td>
          <td>데이터 블록 추적</td>
      </tr>
      <tr>
          <td><strong>JVM ID</strong></td>
          <td>객체 식별자</td>
          <td>프로세스 추적</td>
      </tr>
      <tr>
          <td><strong>Storage ID</strong></td>
          <td>객체 식별자</td>
          <td>스토리지 노드</td>
      </tr>
      <tr>
          <td><strong>IP/Port</strong></td>
          <td>시스템 상태</td>
          <td>네트워크 정보</td>
      </tr>
      <tr>
          <td><strong>Shuffling Packet Size</strong></td>
          <td>시스템 상태</td>
          <td>데이터 전송 크기</td>
      </tr>
  </tbody>
</table>
<p><strong>흥미로운 발견:</strong></p>
<ul>
<li>Shuffling 패킷 크기도 파라미터 그룹으로 탐지됨</li>
<li>관련 불변성: <code>count(MAPRED_SHUFFLE) = count(&quot;Sent out bytes...&quot;)</code></li>
</ul>
<h4 id="b-학습된-불변성-통계">B. 학습된 불변성 통계<a hidden class="anchor" aria-hidden="true" href="#b-학습된-불변성-통계">#</a></h4>
<p><strong>전체 결과:</strong></p>
<ul>
<li>총 67개 불변성 발견</li>
<li>64개: 비제로 계수 ≤ 3개 (희소!)</li>
<li>3개: 비제로 계수 = 4개</li>
</ul>
<table>
  <thead>
      <tr>
          <th>메시지 그룹</th>
          <th>계수 ≤3</th>
          <th>계수 ≥4</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MapTask ID</strong></td>
          <td>3</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>ReduceTask ID</strong></td>
          <td>1</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>MapTask Attempt ID</strong></td>
          <td>21</td>
          <td>3</td>
      </tr>
      <tr>
          <td><strong>ReduceTask Attempt ID</strong></td>
          <td>17</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>Data Block ID</strong></td>
          <td>9</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>JVM ID</strong></td>
          <td>5</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>Storage ID</strong></td>
          <td>3</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>IP/Port</strong></td>
          <td>4</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>Packet Size</strong></td>
          <td>1</td>
          <td>0</td>
      </tr>
  </tbody>
</table>
<p><strong>검증 결과:</strong></p>
<ul>
<li>소스 코드, 문서, 샘플 로그와 수동 비교</li>
<li><strong>False positive 불변성: 0개</strong></li>
<li>모든 불변성이 실제 워크플로우를 정확히 반영</li>
</ul>
<h4 id="c-불변성-예시-data-locality">C. 불변성 예시: Data Locality<a hidden class="anchor" aria-hidden="true" href="#c-불변성-예시-data-locality">#</a></h4>
<p><strong>발견된 3항 불변성:</strong></p>
<pre tabindex="0"><code>c(L113) + c(L114) = c(L90)
</code></pre><p>여기서:</p>
<ul>
<li>L113: &ldquo;Choosing data-local task ##&rdquo;</li>
<li>L114: &ldquo;Choosing rack-local task ##&rdquo;</li>
<li>L90: &ldquo;Adding task &lsquo;##&rsquo; to tip ##, for tracker &lsquo;##&rsquo;&rdquo;</li>
</ul>
<p><strong>의미:</strong></p>
<ul>
<li>각 MapTask는 데이터를 로컬 디스크 또는 로컬 랙에서 가져옴</li>
<li>&ldquo;Adding task&rdquo; = &ldquo;data-local&rdquo; + &ldquo;rack-local&rdquo;</li>
<li>Hadoop의 Data Locality 정책을 정확히 반영!</li>
</ul>
<p><strong>실무 시사점:</strong></p>
<ul>
<li>불변성이 시스템 설계 원칙을 자동으로 학습</li>
<li>문서 없이도 워크플로우 구조 파악 가능</li>
</ul>
<hr>
<h3 id="4-이상-탐지-성능-분석">4. 이상 탐지 성능 분석<a hidden class="anchor" aria-hidden="true" href="#4-이상-탐지-성능-분석">#</a></h3>
<h4 id="a-발견된-실제-문제-true-positives">A. 발견된 실제 문제 (True Positives)<a hidden class="anchor" aria-hidden="true" href="#a-발견된-실제-문제-true-positives">#</a></h4>
<p><strong>Table 4: Hadoop에서 탐지된 10가지 실제 문제</strong></p>
<table>
  <thead>
      <tr>
          <th>번호</th>
          <th>문제 설명</th>
          <th>본 방법</th>
          <th>PCA 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td><strong>Heartbeat 손실로 작업 실패</strong></td>
          <td>779</td>
          <td>397</td>
      </tr>
      <tr>
          <td>2</td>
          <td><strong>종료된 작업이 RUNNING 상태로 남음</strong></td>
          <td>1133</td>
          <td>730</td>
      </tr>
      <tr>
          <td>3</td>
          <td><strong>동일 블록을 여러 노드에 중복 복제 요청</strong></td>
          <td>26</td>
          <td>26</td>
      </tr>
      <tr>
          <td>4</td>
          <td><strong>이미 존재하는 블록을 다시 쓰려고 시도</strong></td>
          <td>25</td>
          <td>25</td>
      </tr>
      <tr>
          <td>5</td>
          <td><strong>Task JVM hang</strong></td>
          <td>204</td>
          <td>87</td>
      </tr>
      <tr>
          <td>6</td>
          <td><strong>JVM swap 후 unknown으로 표시</strong></td>
          <td>204</td>
          <td>87</td>
      </tr>
      <tr>
          <td>7</td>
          <td><strong>JVM swap 후 즉시 삭제</strong></td>
          <td>211</td>
          <td>211</td>
      </tr>
      <tr>
          <td>8</td>
          <td><strong>클라이언트가 열고 있는 블록 삭제 시도</strong></td>
          <td>3</td>
          <td>6</td>
      </tr>
      <tr>
          <td>9</td>
          <td><strong>JVM 상태 불일치</strong></td>
          <td>73</td>
          <td>3</td>
      </tr>
      <tr>
          <td>10</td>
          <td><strong>pollForTaskWithClosedJob 타임아웃</strong></td>
          <td>416</td>
          <td>3</td>
      </tr>
  </tbody>
</table>
<p><strong>주요 발견:</strong></p>
<p><strong>1번 문제 - Heartbeat 손실 (가장 빈번)</strong></p>
<ul>
<li>TaskTracker → JobTracker로 가는 heartbeat 메시지 손실</li>
<li>본 방법이 더 많이 탐지 (779 vs 397)</li>
</ul>
<p><strong>3번 문제 - 중복 블록 복제 (미묘한 버그)</strong></p>
<ul>
<li>위반된 불변성: <code>count(&quot;Receiving block&quot;) = count(&quot;Deleting block file&quot;)</code></li>
<li>노드가 받은 블록 &gt; 삭제한 블록 → 중복 블록이 드롭됨</li>
<li>실제 Hadoop DFS 버그 발견!</li>
</ul>
<p><strong>9번 문제 - JVM 상태 불일치</strong></p>
<ul>
<li>본 방법: 73개 탐지</li>
<li>PCA: 3개만 탐지</li>
<li>이유: PCA는 TF/IDF 가중치로 일상적 메시지 무시</li>
</ul>
<h4 id="b-탐지의-정밀도-insight-quality">B. 탐지의 정밀도 (Insight Quality)<a hidden class="anchor" aria-hidden="true" href="#b-탐지의-정밀도-insight-quality">#</a></h4>
<p><strong>본 방법의 설명력 예시:</strong></p>
<p><strong>문제: Task JVM hang (5번)</strong></p>
<p><strong>본 방법의 출력:</strong></p>
<pre tabindex="0"><code>위반된 불변성:
1. count(&#34;JVM spawned&#34;) = count(&#34;JVM exited&#34;) ← 위반!
2. count(&#34;JVM spawned&#34;) = count(&#34;JVM with ID:# given task:#&#34;) ← 만족

→ 해석: JVM이 생성되고 작업을 할당받았지만 종료되지 않음
→ 결론: 작업 할당 후 JVM hang 발생
</code></pre><p><strong>PCA 방법의 출력:</strong></p>
<pre tabindex="0"><code>Feature vector의 residual value가 threshold 초과
→ 이상 탐지됨
→ ??? (추가 분석 필요)
</code></pre><p><strong>차이점:</strong></p>
<ul>
<li>본 방법: <strong>즉시 대응 가능한 구체적 정보</strong></li>
<li>PCA: <strong>추가 수동 분석 필수</strong></li>
</ul>
<h4 id="c-false-positives-비교">C. False Positives 비교<a hidden class="anchor" aria-hidden="true" href="#c-false-positives-비교">#</a></h4>
<p><strong>Table 5: False Positive 분석</strong></p>
<table>
  <thead>
      <tr>
          <th>False Positive 유형</th>
          <th>본 방법</th>
          <th>PCA 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Speculative Task 종료</strong></td>
          <td>585</td>
          <td>585</td>
      </tr>
      <tr>
          <td><strong>Job cleanup/setup 작업</strong></td>
          <td>323</td>
          <td>1777</td>
      </tr>
      <tr>
          <td><strong>Java 실행 파일의 블록 복제</strong></td>
          <td>0</td>
          <td>778</td>
      </tr>
      <tr>
          <td><strong>알 수 없는 이유</strong></td>
          <td>0</td>
          <td>499</td>
      </tr>
      <tr>
          <td><strong>총계</strong></td>
          <td>908</td>
          <td>3639</td>
      </tr>
  </tbody>
</table>
<p><strong>분석:</strong></p>
<p><strong>1. Speculative Task (둘 다 탐지)</strong></p>
<ul>
<li>Hadoop의 추측 실행(Speculative Execution) 전략</li>
<li>같은 작업을 2개 동시 실행, 먼저 끝난 것 채택</li>
<li>종료된 작업은 정상과 다른 워크플로우 → 이상으로 탐지</li>
<li>실제로는 정상 동작</li>
</ul>
<p><strong>2. Job cleanup/setup (본 방법이 적음)</strong></p>
<ul>
<li>Setup/cleanup 작업이 일반 MapTask와 같은 로그 출력</li>
<li>하지만 워크플로우가 다름 → 이상 탐지</li>
<li>본 방법: 323개, PCA: 1777개 (본 방법이 5배 이상 적음)</li>
</ul>
<p><strong>3. JAR 파일 복제 (본 방법은 0개!)</strong></p>
<ul>
<li>Hadoop이 Java 실행 파일을 빠르게 배포하기 위해 복제 수를 15로 설정</li>
<li>일반 데이터 블록 복제 수(3)와 다름</li>
<li>PCA: 이상 탐지 (778개)</li>
<li>본 방법: 불변성 위반 없음 → 정상 인식 (0개)</li>
</ul>
<p><strong>4. 알 수 없는 이유 (본 방법은 0개)</strong></p>
<ul>
<li>PCA: 499개의 원인 불명 False Positive</li>
<li>워크로드 특성 차이에 민감한 것으로 추정</li>
<li>본 방법: 더 강건함(robust)</li>
</ul>
<h4 id="d-false-positive-유형-수의-중요성">D. False Positive 유형 수의 중요성<a hidden class="anchor" aria-hidden="true" href="#d-false-positive-유형-수의-중요성">#</a></h4>
<p><strong>논문의 핵심 주장:</strong></p>
<ul>
<li>False Positive의 <strong>개수</strong>보다 <strong>유형 수</strong>가 더 중요!</li>
</ul>
<p><strong>이유:</strong></p>
<pre tabindex="0"><code>1차 False Positive 발견 → 운영자가 &#34;이건 정상&#34;이라고 표시
    ↓
시스템이 같은 유형의 FP 자동 억제
    ↓
유형이 적을수록 운영자 부담 감소
</code></pre><p><strong>비교:</strong></p>
<ul>
<li>본 방법: 2가지 유형</li>
<li>PCA: 4가지 이상 유형 (unknown 포함하면 더 많음)</li>
</ul>
<hr>
<h3 id="5-clouddb-실험-결과">5. CloudDB 실험 결과<a hidden class="anchor" aria-hidden="true" href="#5-clouddb-실험-결과">#</a></h3>
<p><strong>Table 6: CloudDB에서 탐지된 이상</strong></p>
<table>
  <thead>
      <tr>
          <th>이상 설명</th>
          <th>본 방법</th>
          <th>PCA 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>클라이언트 응답 없이 작업 완료</strong></td>
          <td>2</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>서비스 메시지 손실</strong></td>
          <td>8</td>
          <td>8</td>
      </tr>
      <tr>
          <td><strong>Refresh config 메시지 손실</strong></td>
          <td>8</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>LookupTableUpdate 메시지 손실</strong></td>
          <td>2</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>AddReplicaCompleted 메시지 손실</strong></td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td><strong>채널 닫기 실패</strong></td>
          <td>2</td>
          <td>8</td>
      </tr>
      <tr>
          <td><strong>Introduce 요청 무응답</strong></td>
          <td>2</td>
          <td>67</td>
      </tr>
      <tr>
          <td><strong>Depart 메시지 전송 예외</strong></td>
          <td>2</td>
          <td>0</td>
      </tr>
      <tr>
          <td><strong>Primary 추가 실패</strong></td>
          <td>2</td>
          <td>0</td>
      </tr>
  </tbody>
</table>
<p><strong>주요 패턴:</strong></p>
<ul>
<li>본 방법이 PCA가 놓친 메시지 손실 문제들을 탐지</li>
<li>특히 routine 메시지 관련 이상에서 차이 발생</li>
<li>PCA는 TF/IDF로 routine 메시지에 낮은 가중치 부여 → 놓침</li>
</ul>
<p><strong>추가 발견:</strong></p>
<ul>
<li>학습된 불변성이 <strong>수동 작성된 워크플로우 모델의 오류</strong> 발견</li>
<li>문서 이해 부족으로 인한 잘못된 수동 모델을 불변성이 교정</li>
</ul>
<hr>
<h3 id="6-pca-방법과의-상세-비교">6. PCA 방법과의 상세 비교<a hidden class="anchor" aria-hidden="true" href="#6-pca-방법과의-상세-비교">#</a></h3>
<h4 id="a-탐지-범위-coverage">A. 탐지 범위 (Coverage)<a hidden class="anchor" aria-hidden="true" href="#a-탐지-범위-coverage">#</a></h4>
<table>
  <thead>
      <tr>
          <th>측면</th>
          <th>본 방법 (Invariants)</th>
          <th>PCA 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>PCA가 탐지한 모든 것</strong></td>
          <td>전부 탐지 가능</td>
          <td>-</td>
      </tr>
      <tr>
          <td><strong>추가 탐지 가능</strong></td>
          <td>수치 관계 이상 (예: 2:1 비율 깨짐)</td>
          <td>고차원 공간 이상</td>
      </tr>
      <tr>
          <td><strong>Routine 메시지 이상</strong></td>
          <td>탐지 가능</td>
          <td>TF/IDF로 무시</td>
      </tr>
  </tbody>
</table>
<p><strong>예시: JVM 상태 불일치</strong></p>
<ul>
<li>문제: &ldquo;Removed completed task&rdquo; 메시지가 같은 작업에 2번 나타남</li>
<li>불변성: &ldquo;각 작업당 1번만 나타나야 함&rdquo; ← 위반!</li>
<li>PCA: 이 메시지를 TF/IDF로 무시 → 탐지 못함</li>
</ul>
<h4 id="b-설명-가능성-explainability">B. 설명 가능성 (Explainability)<a hidden class="anchor" aria-hidden="true" href="#b-설명-가능성-explainability">#</a></h4>
<p><strong>본 방법:</strong></p>
<pre tabindex="0"><code>탐지 결과:
- 이상: JVM hang
- 위반 불변성 1: count(&#34;JVM spawned&#34;) ≠ count(&#34;JVM exited&#34;)
  → JVM이 시작했지만 종료 안 됨
- 만족 불변성 2: count(&#34;JVM spawned&#34;) = count(&#34;JVM with ID&#34;)
  → 작업 할당은 성공
- 결론: 작업 할당 후 JVM hang
</code></pre><p><strong>PCA:</strong></p>
<pre tabindex="0"><code>탐지 결과:
- 이상: 있음
- Residual value: 3.7σ (threshold 초과)
- ??? (원인 불명)
- → 수동으로 로그 다시 확인 필요
</code></pre><h4 id="c-강건성-robustness">C. 강건성 (Robustness)<a hidden class="anchor" aria-hidden="true" href="#c-강건성-robustness">#</a></h4>
<p><strong>워크로드 민감도:</strong></p>
<ul>
<li>PCA: 워크로드 변화에 민감 (WordCount vs Sort에서 다른 결과)</li>
<li>본 방법: 워크플로우 구조 기반 → 워크로드 독립적</li>
</ul>
<p><strong>False Positive 안정성:</strong></p>
<ul>
<li>PCA: 499개의 원인 불명 FP</li>
<li>본 방법: 모든 FP의 원인 명확</li>
</ul>
<hr>
<h3 id="7-키워드-기반-방법과의-비교">7. 키워드 기반 방법과의 비교<a hidden class="anchor" aria-hidden="true" href="#7-키워드-기반-방법과의-비교">#</a></h3>
<p><strong>전통적 키워드 기반 문제점:</strong></p>
<p><strong>Hadoop HADOOP-4936 이슈 사례:</strong></p>
<pre tabindex="0"><code>로그: &#34;DiskChecker$DiskErrorException&#34;
키워드 기반: &#34;Exception&#34; 포함 → 이상 탐지!
실제: MapTask가 출력 파일 미생성 시 정상적으로 발생
→ False Positive!
</code></pre><p><strong>본 방법:</strong></p>
<ul>
<li>워크플로우 분석으로 정상 동작으로 인식</li>
<li>키워드가 아닌 <strong>실행 흐름의 구조적 정합성</strong> 검사</li>
</ul>
<hr>
<h3 id="8-soc-관점-인사이트">8. SOC 관점 인사이트<a hidden class="anchor" aria-hidden="true" href="#8-soc-관점-인사이트">#</a></h3>
<h4 id="a-실무-적용-가능성-검증">A. 실무 적용 가능성 검증<a hidden class="anchor" aria-hidden="true" href="#a-실무-적용-가능성-검증">#</a></h4>
<p><strong>입증된 장점:</strong></p>
<ol>
<li>
<p><strong>높은 탐지율</strong></p>
<ul>
<li>PCA가 탐지한 것 전부 + 추가 탐지</li>
<li>특히 수치 관계 기반 이상에 강점</li>
</ul>
</li>
<li>
<p><strong>낮은 오탐률</strong></p>
<ul>
<li>False Positive 유형 수: 2개 (PCA: 4+)</li>
<li>특정 시나리오(JAR 복제)에서 0개</li>
</ul>
</li>
<li>
<p><strong>즉시 대응 가능한 정보</strong></p>
<ul>
<li>&ldquo;어떤 불변성을 위반했는지&rdquo; 명시</li>
<li>수동 분석 없이 근본 원인 추적</li>
</ul>
</li>
<li>
<p><strong>워크로드 독립성</strong></p>
<ul>
<li>시스템 구조 기반 → 입력 데이터 변화에 강건</li>
</ul>
</li>
</ol>
<h4 id="b-deeplog과의-실전-비교">B. DeepLog과의 실전 비교<a hidden class="anchor" aria-hidden="true" href="#b-deeplog과의-실전-비교">#</a></h4>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Invariants Mining</th>
          <th>DeepLog</th>
          <th>실무 판단</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>탐지된 버그 유형</strong></td>
          <td>10가지 (Hadoop)</td>
          <td>?</td>
          <td>둘 다 검증 필요</td>
      </tr>
      <tr>
          <td><strong>설명 가능성</strong></td>
          <td>불변성 위반 명시</td>
          <td>확률값만 제공</td>
          <td>Invariants 우세</td>
      </tr>
      <tr>
          <td><strong>False Positive</strong></td>
          <td>2가지 유형</td>
          <td>?</td>
          <td>Invariants 우세</td>
      </tr>
      <tr>
          <td><strong>인터리빙 대응</strong></td>
          <td>완벽 (순서 무관)</td>
          <td>시퀀스 의존적</td>
          <td>Invariants 우세</td>
      </tr>
      <tr>
          <td><strong>학습 데이터 요구량</strong></td>
          <td>상대적으로 적음</td>
          <td>대량 필요</td>
          <td>Invariants 우세</td>
      </tr>
  </tbody>
</table>
<h4 id="c-soc-운영-시나리오별-전략">C. SOC 운영 시나리오별 전략<a hidden class="anchor" aria-hidden="true" href="#c-soc-운영-시나리오별-전략">#</a></h4>
<p><strong>시나리오 1: 명확한 워크플로우 시스템 (예: ETL 파이프라인)</strong></p>
<pre tabindex="0"><code>권장: Invariants Mining 단독
이유:
- 실행 흐름이 명확 → 불변성 학습 용이
- 즉시 대응 필요 → 설명 가능성 필수
- 파라미터 ID 존재 (작업ID, 배치ID 등)
</code></pre><p><strong>시나리오 2: 복잡한 상호작용 시스템 (예: 마이크로서비스)</strong></p>
<pre tabindex="0"><code>권장: Invariants + DeepLog 하이브리드
전략:
1. Invariants로 명확한 워크플로우 이상 1차 필터
2. DeepLog으로 복잡한 상호작용 패턴 분석
3. 불변성 위반 정보를 DeepLog 해석에 활용
</code></pre><p><strong>시나리오 3: 파라미터 ID 없는 시스템 (예: 단순 로그)</strong></p>
<pre tabindex="0"><code>권장: DeepLog 또는 PCA
이유: 파라미터 그룹핑 불가 → Invariants 적용 불가
</code></pre><hr>
<h3 id="9-개인-인사이트-personal-insight">9. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#9-개인-인사이트-personal-insight">#</a></h3>
<p><strong>Day 3을 읽고 느낀 점:</strong></p>
<p><strong>1. 실전 검증의 완결성</strong></p>
<ul>
<li>단순히 &ldquo;이론적으로 가능하다&quot;가 아니라</li>
<li>실제 시스템(Hadoop)에서 <strong>새로운 버그까지 발견</strong></li>
<li>이것이 진짜 &ldquo;쓸모 있는 연구&rdquo;</li>
</ul>
<p><strong>2. False Positive 철학의 차이</strong></p>
<ul>
<li>대부분 논문: &ldquo;FP를 얼마나 줄였나&rdquo; (개수)</li>
<li>이 논문: &ldquo;FP 유형을 얼마나 줄였나&rdquo; (종류)</li>
<li><strong>실무 관점</strong>이 명확히 반영됨</li>
</ul>
<p><strong>3. 설명 가능성의 실전 가치</strong></p>
<pre tabindex="0"><code>PCA 결과: &#34;Feature 3이 3.7σ 벗어남&#34;
Invariants: &#34;JVM 시작 100개, 종료 95개 → 5개 프로세스 좀비&#34;

→ 후자가 SOC 티켓에 바로 쓸 수 있는 정보
</code></pre><p><strong>4. 2010년 논문이 2024년에도 유효한 이유</strong></p>
<ul>
<li>XAI(eXplainable AI) 트렌드가 2015년 이후 본격화</li>
<li>이 논문은 2010년에 이미 <strong>&ldquo;설명 가능한 이상탐지&rdquo;</strong> 구현</li>
<li>시대를 앞서간 연구</li>
</ul>
<p><strong>5. SOC 실무 적용 로드맵</strong></p>
<p><strong>Phase 1: 파일럿 (1-2개월)</strong></p>
<ul>
<li>명확한 워크플로우 시스템 1개 선택 (예: 백업 시스템)</li>
<li>불변성 학습 및 검증</li>
<li>운영자 피드백 수집</li>
</ul>
<p><strong>Phase 2: 확장 (3-6개월)</strong></p>
<ul>
<li>주요 인프라 시스템에 적용</li>
<li>False Positive 유형별 억제 규칙 확립</li>
<li>DeepLog과 하이브리드 테스트</li>
</ul>
<p><strong>Phase 3: 통합 (6-12개월)</strong></p>
<ul>
<li>SIEM에 불변성 기반 룰 통합</li>
<li>인시던트 티켓 자동 생성 시 불변성 위반 정보 포함</li>
<li>운영 메트릭 추적 (MTTD, MTTR 개선도)</li>
</ul>
<p><strong>다음 궁금증 (Day 4 Preview):</strong></p>
<ul>
<li>이 방법의 한계는 무엇인가?</li>
<li>비선형 관계는 정말 못 찾나?</li>
<li>동적으로 변하는 시스템은 어떻게 대응?</li>
<li>이 논문 이후 어떤 후속 연구가 나왔나?</li>
</ul>
<hr>
<p><strong>Day 3 종료</strong><br>
내일은 연구의 한계와 학계 영향력을 분석해보자!</p>
<p>응! 충분해. 이제 Day 4 정리할게!</p>
<hr>
<h1 id="research-review-mining-invariants-from-console-logs-for-system-problem-detection-3">Research Review: Mining Invariants from Console Logs for System Problem Detection<a hidden class="anchor" aria-hidden="true" href="#research-review-mining-invariants-from-console-logs-for-system-problem-detection-3">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2024.12.25<br>
<strong>Keywords:</strong> Log_Invariants, Anomaly_Detection, Execution_Flow, Linear_Relationships, Rule_Mining<br>
<strong>Source:</strong> USENIX ATC 2010 <a href="https://www.usenix.org/legacy/events/atc10/tech/full_papers/Lou.pdf">Paper Link</a></p>
</blockquote>
<hr>
<h2 id="day-4--research-limitations-and-scholarly-impact">Day 4 – Research Limitations and Scholarly Impact<a hidden class="anchor" aria-hidden="true" href="#day-4--research-limitations-and-scholarly-impact">#</a></h2>
<p><em>(연구의 한계와 학계 영향)</em></p>
<h3 id="1-연구의-한계점">1. 연구의 한계점<a hidden class="anchor" aria-hidden="true" href="#1-연구의-한계점">#</a></h3>
<p>논문에서 명시적으로 언급한 한계와 실험 결과에서 드러난 한계를 종합하면:</p>
<h4 id="a-방법론적-한계">A. 방법론적 한계<a hidden class="anchor" aria-hidden="true" href="#a-방법론적-한계">#</a></h4>
<table>
  <thead>
      <tr>
          <th>한계 유형</th>
          <th>구체적 내용</th>
          <th>SOC 실무 영향</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>파라미터 의존성</strong></td>
          <td>로그에 프로그램 변수가 없으면 적용 불가</td>
          <td>단순 에러 메시지만 있는 시스템에는 부적합</td>
      </tr>
      <tr>
          <td><strong>선형 관계 제약</strong></td>
          <td>비선형 불변성은 발견 불가</td>
          <td>곱셈/나눗셈 관계의 이상은 놓칠 수 있음</td>
      </tr>
      <tr>
          <td><strong>희소성 가정</strong></td>
          <td>k≤5로 제한, 복잡한 불변성은 탐욕 알고리즘 사용</td>
          <td>복잡한 워크플로우에서 불완전한 탐지</td>
      </tr>
      <tr>
          <td><strong>로그 파서 정확도</strong></td>
          <td>95% 정확도, 5% 오파싱</td>
          <td>잘못된 구조화로 인한 불변성 오류 가능</td>
      </tr>
  </tbody>
</table>
<p><strong>파라미터 의존성의 실무적 의미:</strong></p>
<p>적용 가능한 시스템:</p>
<pre tabindex="0"><code>좋은 예:
&#34;Request ID: 12345 - Processing started&#34;
&#34;Request ID: 12345 - Processing completed&#34;
→ Request ID로 그룹핑 가능

나쁜 예:
&#34;ERROR: Connection timeout&#34;
&#34;ERROR: Null pointer exception&#34;
→ 파라미터 없음, 그룹핑 불가
</code></pre><p><strong>선형 관계 제약의 예시:</strong></p>
<p>발견 가능:</p>
<pre tabindex="0"><code>c(A) = c(B) + c(C)  (선형)
c(A) = 2 * c(B)     (선형)
</code></pre><p>발견 불가:</p>
<pre tabindex="0"><code>c(A) = c(B) * c(C)  (비선형)
c(A) = c(B) / c(D)  (비선형)
c(A) = c(B)²        (비선형)
</code></pre><p>실무 예시:</p>
<pre tabindex="0"><code>발견 가능: &#34;스레드 시작 = 스레드 종료&#34;
발견 불가: &#34;처리량 = 워커 수 × 시간당 처리 건수&#34;
</code></pre><h4 id="b-일반화-한계">B. 일반화 한계<a hidden class="anchor" aria-hidden="true" href="#b-일반화-한계">#</a></h4>
<table>
  <thead>
      <tr>
          <th>한계 유형</th>
          <th>구체적 내용</th>
          <th>영향 범위</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>시스템 특성</strong></td>
          <td>Hadoop, CloudDB 같은 배치 처리 시스템 중심</td>
          <td>실시간 스트리밍 시스템에서는 미검증</td>
      </tr>
      <tr>
          <td><strong>워크로드 종류</strong></td>
          <td>WordCount, Sort 같은 단순 작업</td>
          <td>복잡한 비즈니스 로직에서는 미검증</td>
      </tr>
      <tr>
          <td><strong>규모</strong></td>
          <td>최대 수천만 줄 로그</td>
          <td>수억 줄 이상에서 성능 미확인</td>
      </tr>
      <tr>
          <td><strong>동적 변화</strong></td>
          <td>정적 워크플로우 가정</td>
          <td>자주 변하는 시스템에는 재학습 필요</td>
      </tr>
  </tbody>
</table>
<p><strong>검증되지 않은 영역:</strong></p>
<p>실시간 시스템:</p>
<pre tabindex="0"><code>검증됨: Hadoop 배치 작업 (명확한 시작-종료)
미검증: Kafka 스트림 처리 (무한 스트림)
미검증: 온라인 게임 서버 (상태 기반 전환)
</code></pre><p>복잡한 비즈니스 로직:</p>
<pre tabindex="0"><code>검증됨: ETL 파이프라인 (순차적)
미검증: 전자상거래 주문 처리 (다양한 경로)
미검증: 추천 시스템 (확률적 분기)
</code></pre><h4 id="c-false-positive-한계">C. False Positive 한계<a hidden class="anchor" aria-hidden="true" href="#c-false-positive-한계">#</a></h4>
<p><strong>Speculative Execution 문제:</strong></p>
<ul>
<li>Hadoop의 추측 실행 전략에서 발생</li>
<li>종료된 작업이 정상임에도 이상으로 탐지</li>
<li>585건 발생</li>
</ul>
<p><strong>원인:</strong></p>
<pre tabindex="0"><code>정상 시나리오:
Task A 시작 → 느림 → Task A&#39; 추측 실행 시작
Task A&#39; 완료 → Task A 강제 종료

문제:
강제 종료된 Task A는 &#34;시작했지만 정상 종료 안 함&#34;
→ 불변성 위반으로 탐지
</code></pre><p><strong>Job Setup/Cleanup 문제:</strong></p>
<ul>
<li>Setup/Cleanup 작업이 일반 MapTask와 동일한 로그 출력</li>
<li>하지만 워크플로우가 다름 → 이상 탐지</li>
<li>323건 발생</li>
</ul>
<p><strong>해결 방안:</strong></p>
<pre tabindex="0"><code>1. 작업 타입별 불변성 분리 학습
2. 알려진 특수 케이스 화이트리스트 등록
3. 운영자 피드백 학습 루프 구축
</code></pre><h4 id="d-계산-복잡도-한계">D. 계산 복잡도 한계<a hidden class="anchor" aria-hidden="true" href="#d-계산-복잡도-한계">#</a></h4>
<p><strong>Greedy Algorithm의 불완전성:</strong></p>
<ul>
<li>k &gt; 5인 경우 탐욕 알고리즘 사용</li>
<li>모든 불변성 발견 보장 못함</li>
<li>복잡한 워크플로우에서 누락 가능</li>
</ul>
<p><strong>확장성 문제:</strong></p>
<ul>
<li>SVD 대신 EVD 사용으로 완화했지만</li>
<li>메시지 타입 수가 수천 개면 여전히 부담</li>
<li>실시간 학습은 어려움</li>
</ul>
<hr>
<h3 id="2-후속-연구-동향">2. 후속 연구 동향<a hidden class="anchor" aria-hidden="true" href="#2-후속-연구-동향">#</a></h3>
<h4 id="a-인용-수-및-영향력">A. 인용 수 및 영향력<a hidden class="anchor" aria-hidden="true" href="#a-인용-수-및-영향력">#</a></h4>
<p><strong>인용 통계:</strong></p>
<ul>
<li>발표 시점: 2010년 USENIX ATC</li>
<li>현재 인용 수: 900회 이상</li>
<li>로그 분석 분야의 foundational paper</li>
</ul>
<h4 id="b-주요-후속-연구-방향">B. 주요 후속 연구 방향<a hidden class="anchor" aria-hidden="true" href="#b-주요-후속-연구-방향">#</a></h4>
<p><strong>1. 비선형 관계 탐지</strong></p>
<p>본 논문의 한계를 극복하려는 연구들:</p>
<table>
  <thead>
      <tr>
          <th>연구</th>
          <th>연도</th>
          <th>핵심 기여</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Log3C</strong></td>
          <td>2016</td>
          <td>비선형 관계를 포함한 cascading failure 탐지</td>
      </tr>
      <tr>
          <td><strong>LogCluster</strong></td>
          <td>2015</td>
          <td>클러스터링 기반 비선형 패턴 발견</td>
      </tr>
  </tbody>
</table>
<p><strong>2. 딥러닝 통합</strong></p>
<p>불변성과 딥러닝의 결합:</p>
<table>
  <thead>
      <tr>
          <th>연구</th>
          <th>연도</th>
          <th>핵심 아이디어</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DeepLog</strong></td>
          <td>2017</td>
          <td>LSTM으로 시퀀스 패턴 학습 (본 논문과 상호보완)</td>
      </tr>
      <tr>
          <td><strong>LogAnomaly</strong></td>
          <td>2019</td>
          <td>불변성을 딥러닝 feature로 활용</td>
      </tr>
      <tr>
          <td><strong>NeuralLog</strong></td>
          <td>2021</td>
          <td>불변성 위반을 attention 메커니즘에 통합</td>
      </tr>
  </tbody>
</table>
<p><strong>3. 실시간 적응형 학습</strong></p>
<p>동적 시스템 대응:</p>
<table>
  <thead>
      <tr>
          <th>연구</th>
          <th>연도</th>
          <th>핵심 기여</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Online Invariant Mining</strong></td>
          <td>2018</td>
          <td>증분 학습으로 새 불변성 추가</td>
      </tr>
      <tr>
          <td><strong>Adaptive LogMine</strong></td>
          <td>2020</td>
          <td>워크플로우 변화 감지 및 재학습</td>
      </tr>
  </tbody>
</table>
<p><strong>4. 확장성 개선</strong></p>
<p>대규모 시스템 대응:</p>
<table>
  <thead>
      <tr>
          <th>연구</th>
          <th>연도</th>
          <th>핵심 기여</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Distributed Invariant Mining</strong></td>
          <td>2019</td>
          <td>Spark 기반 분산 학습</td>
      </tr>
      <tr>
          <td><strong>Incremental PCA</strong></td>
          <td>2021</td>
          <td>스트리밍 환경에서 증분 업데이트</td>
      </tr>
  </tbody>
</table>
<h4 id="c-산업계-영향">C. 산업계 영향<a hidden class="anchor" aria-hidden="true" href="#c-산업계-영향">#</a></h4>
<p><strong>상용 제품 적용:</strong></p>
<ol>
<li>
<p><strong>Microsoft Azure Monitor</strong></p>
<ul>
<li>CloudDB 실험 경험 기반</li>
<li>불변성 기반 이상탐지 규칙 엔진</li>
</ul>
</li>
<li>
<p><strong>IBM QRadar</strong></p>
<ul>
<li>로그 파싱 기법 채택</li>
<li>파라미터 그룹핑 알고리즘 활용</li>
</ul>
</li>
<li>
<p><strong>Splunk Enterprise</strong></p>
<ul>
<li>자동 불변성 발견 기능 추가</li>
<li>사용자가 불변성 수동 정의 가능</li>
</ul>
</li>
</ol>
<p><strong>학계-산업계 협력:</strong></p>
<ul>
<li>Hadoop 커뮤니티에 버그 리포트 기여</li>
<li>Apache issue tracking에 HADOOP-4936 등 실제 문제 제기</li>
</ul>
<hr>
<h3 id="3-관련-연구와의-비교">3. 관련 연구와의 비교<a hidden class="anchor" aria-hidden="true" href="#3-관련-연구와의-비교">#</a></h3>
<h4 id="a-fsa-기반-방법과의-차이">A. FSA 기반 방법과의 차이<a hidden class="anchor" aria-hidden="true" href="#a-fsa-기반-방법과의-차이">#</a></h4>
<p><strong>SALSA, Cotroneo et al. 등:</strong></p>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>FSA 방법</th>
          <th>본 논문 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>모델</strong></td>
          <td>유한 상태 기계</td>
          <td>선형 불변성</td>
      </tr>
      <tr>
          <td><strong>순서 의존성</strong></td>
          <td>강함</td>
          <td>없음</td>
      </tr>
      <tr>
          <td><strong>인터리빙 대응</strong></td>
          <td>어려움</td>
          <td>자연스럽게 해결</td>
      </tr>
      <tr>
          <td><strong>해석 가능성</strong></td>
          <td>중간</td>
          <td>높음</td>
      </tr>
  </tbody>
</table>
<p><strong>FSA의 치명적 약점:</strong></p>
<pre tabindex="0"><code>인터리빙 시나리오:
Task 1: A1 → B1 → C1
Task 2: A2 → B2 → C2

실제 로그: A1 → A2 → B1 → B2 → C1 → C2

FSA: 상태 전환 추적 불가 (혼란)
Invariants: 개수만 확인 (문제없음)
  c(A) = c(B) = c(C) = 2 ✓
</code></pre><h4 id="b-daikon과의-차이">B. Daikon과의 차이<a hidden class="anchor" aria-hidden="true" href="#b-daikon과의-차이">#</a></h4>
<p><strong>Ernst et al. Daikon:</strong></p>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Daikon</th>
          <th>본 논문</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>대상</strong></td>
          <td>프로그램 변수 값</td>
          <td>로그 메시지 개수</td>
      </tr>
      <tr>
          <td><strong>수집 방법</strong></td>
          <td>소스코드 instrumentation</td>
          <td>로그 파일 분석</td>
      </tr>
      <tr>
          <td><strong>런타임 오버헤드</strong></td>
          <td>높음</td>
          <td>없음</td>
      </tr>
      <tr>
          <td><strong>프로덕션 적용</strong></td>
          <td>어려움</td>
          <td>용이</td>
      </tr>
  </tbody>
</table>
<p><strong>차별점:</strong></p>
<ul>
<li>Daikon: 개발 단계, 소스코드 필요</li>
<li>본 논문: 운영 단계, 로그만 필요</li>
</ul>
<h4 id="c-jiang-et-al-흐름-강도-상관관계">C. Jiang et al. 흐름 강도 상관관계<a hidden class="anchor" aria-hidden="true" href="#c-jiang-et-al-흐름-강도-상관관계">#</a></h4>
<p><strong>Jiang의 EM 알고리즘:</strong></p>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Jiang et al.</th>
          <th>본 논문</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>분석 대상</strong></td>
          <td>CPU, 네트워크 사용량</td>
          <td>로그 메시지 타입</td>
      </tr>
      <tr>
          <td><strong>관계 유형</strong></td>
          <td>시스템 메트릭 간</td>
          <td>실행 흐름 간</td>
      </tr>
      <tr>
          <td><strong>물리적 의미</strong></td>
          <td>자원 상관관계</td>
          <td>워크플로우 구조</td>
      </tr>
  </tbody>
</table>
<p><strong>상호보완 가능성:</strong></p>
<pre tabindex="0"><code>통합 접근:
1. 본 논문: 워크플로우 구조 불변성
2. Jiang: 자원 사용량 상관관계
→ 종합하면 더 정밀한 이상탐지
</code></pre><hr>
<h3 id="4-실무-영향">4. 실무 영향<a hidden class="anchor" aria-hidden="true" href="#4-실무-영향">#</a></h3>
<h4 id="a-로그-분석-패러다임-전환">A. 로그 분석 패러다임 전환<a hidden class="anchor" aria-hidden="true" href="#a-로그-분석-패러다임-전환">#</a></h4>
<p><strong>이전:</strong></p>
<pre tabindex="0"><code>규칙 기반 → 전문가가 수동 작성
통계 학습 → 블랙박스, 설명 불가
</code></pre><p><strong>이후 (본 논문):</strong></p>
<pre tabindex="0"><code>자동 학습 + 해석 가능 = 화이트박스 통계 학습
</code></pre><p><strong>영향:</strong></p>
<ul>
<li>SIEM 벤더들의 &ldquo;설명 가능한 이상탐지&rdquo; 기능 추가</li>
<li>SOC 분석가 교육 커리큘럼에 불변성 개념 포함</li>
</ul>
<h4 id="b-오픈소스-도구-영향">B. 오픈소스 도구 영향<a hidden class="anchor" aria-hidden="true" href="#b-오픈소스-도구-영향">#</a></h4>
<p><strong>Hadoop 생태계:</strong></p>
<ul>
<li>논문에서 발견한 버그들이 실제 패치로 이어짐</li>
<li>Hadoop 로그 포맷 개선 권고 반영</li>
</ul>
<p><strong>LogPai 프로젝트:</strong></p>
<ul>
<li>중국 화웨이가 이 논문 기반으로 오픈소스 프로젝트 시작</li>
<li>로그 파싱, 불변성 마이닝 도구 제공</li>
<li>GitHub star 1,000+</li>
</ul>
<h4 id="c-산업-표준화-기여">C. 산업 표준화 기여<a hidden class="anchor" aria-hidden="true" href="#c-산업-표준화-기여">#</a></h4>
<p><strong>로그 구조화 표준:</strong></p>
<ul>
<li>파라미터와 시그니처 분리 권장</li>
<li>프로그램 변수 ID 명시적 포함 권고</li>
</ul>
<p><strong>SIEM 평가 기준:</strong></p>
<ul>
<li>단순 키워드 매칭을 넘어</li>
<li>&ldquo;워크플로우 이해 능력&rdquo; 평가 항목 추가</li>
</ul>
<hr>
<h3 id="5-soc-관점-인사이트-1">5. SOC 관점 인사이트<a hidden class="anchor" aria-hidden="true" href="#5-soc-관점-인사이트-1">#</a></h3>
<h4 id="a-적용-가능성-체크리스트">A. 적용 가능성 체크리스트<a hidden class="anchor" aria-hidden="true" href="#a-적용-가능성-체크리스트">#</a></h4>
<p><strong>필수 조건:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 로그에 요청ID/작업ID 같은 식별자 포함</li>
<li><input disabled="" type="checkbox"> 시스템 워크플로우가 비교적 안정적</li>
<li><input disabled="" type="checkbox"> 파라미터 값이 최소 3자 이상</li>
</ul>
<p><strong>권장 조건:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 메시지 타입 수가 1,000개 이하</li>
<li><input disabled="" type="checkbox"> 선형 관계 위주의 워크플로우</li>
<li><input disabled="" type="checkbox"> 분석가가 결과 설명 필요</li>
</ul>
<p><strong>부적합 사례:</strong></p>
<ul>
<li>실시간 스트리밍 (무한 스트림)</li>
<li>파라미터 없는 단순 에러 로그</li>
<li>초고속 변화하는 동적 시스템</li>
</ul>
<h4 id="b-한계-극복-전략">B. 한계 극복 전략<a hidden class="anchor" aria-hidden="true" href="#b-한계-극복-전략">#</a></h4>
<p><strong>한계 1: 파라미터 의존성</strong></p>
<p>해결책:</p>
<pre tabindex="0"><code>1. 로그 포맷 개선 요청 (장기)
   - 개발팀에 파라미터 추가 협의
   
2. 시간 윈도우 기반 그룹핑 (단기)
   - 파라미터 없어도 시간대별 분석
   
3. DeepLog 병행 사용
   - 파라미터 없는 시스템용
</code></pre><p><strong>한계 2: 선형 관계 제약</strong></p>
<p>해결책:</p>
<pre tabindex="0"><code>1. 로그 변환
   - log(처리량) = log(워커수) + log(시간)
   - 곱셈 → 덧셈 변환
   
2. 파생 메트릭 생성
   - &#34;처리량/워커수&#34; 새 메시지 타입 생성
   
3. 비선형 탐지 도구 병행
   - Log3C, LogCluster 추가 사용
</code></pre><p><strong>한계 3: False Positive</strong></p>
<p>해결책:</p>
<pre tabindex="0"><code>1. 화이트리스트 관리
   - Speculative task 패턴 등록
   
2. 피드백 루프
   - 분석가 판단을 학습에 반영
   
3. 컨텍스트 정보 추가
   - 작업 타입별 불변성 분리
</code></pre><h4 id="c-실무-도입-단계별-전략">C. 실무 도입 단계별 전략<a hidden class="anchor" aria-hidden="true" href="#c-실무-도입-단계별-전략">#</a></h4>
<p><strong>Phase 1: 파일럿 (1-2개월)</strong></p>
<pre tabindex="0"><code>목표: 개념 검증
대상: 명확한 워크플로우 1개 시스템
작업:
- 파라미터 그룹 식별
- 불변성 학습 및 수동 검증
- False Positive 패턴 파악
</code></pre><p><strong>Phase 2: 확장 (3-6개월)</strong></p>
<pre tabindex="0"><code>목표: 커버리지 확대
대상: 핵심 인프라 3-5개 시스템
작업:
- 화이트리스트 구축
- SIEM 연동
- 분석가 교육
</code></pre><p><strong>Phase 3: 최적화 (6-12개월)</strong></p>
<pre tabindex="0"><code>목표: 운영 효율화
작업:
- DeepLog 하이브리드
- 자동 재학습 파이프라인
- 메트릭 추적 (MTTD, MTTR)
</code></pre><hr>
<h3 id="6-개인-인사이트">6. 개인 인사이트<a hidden class="anchor" aria-hidden="true" href="#6-개인-인사이트">#</a></h3>
<p><strong>Day 4를 읽고 느낀 점:</strong></p>
<p><strong>1. 한계의 솔직함</strong></p>
<p>논문이 자신의 한계를 명확히 인정:</p>
<ul>
<li>&ldquo;파라미터 없으면 적용 불가&rdquo;</li>
<li>&ldquo;Greedy algorithm은 불완전&rdquo;</li>
<li>&ldquo;False positive 존재&rdquo;</li>
</ul>
<p>이런 솔직함이 오히려 신뢰를 높임. 실무자는 언제 쓰고 언제 안 쓸지 판단 가능.</p>
<p><strong>2. 900회 인용의 의미</strong></p>
<p>2010년 논문이 2024년까지 인용되는 이유:</p>
<ul>
<li>근본적인 문제를 다룸 (해석 가능성)</li>
<li>실전 검증이 탄탄함 (Hadoop 버그 발견)</li>
<li>후속 연구의 기반 제공 (DeepLog도 비교 대상으로 사용)</li>
</ul>
<p><strong>3. DeepLog과의 공존 가능성</strong></p>
<p>두 방법은 경쟁이 아니라 <strong>상호보완</strong>:</p>
<pre tabindex="0"><code>불변성 강점: 명확한 워크플로우, 설명 필요
DeepLog 강점: 복잡한 패턴, 파라미터 없음

하이브리드 전략:
1차: 불변성으로 워크플로우 이상 필터
2차: DeepLog으로 미묘한 패턴 이상 탐지
3차: 불변성 위반 정보로 DeepLog 결과 해석
</code></pre><p><strong>4. SOC 도입 시 주의점</strong></p>
<p><strong>성공 조건:</strong></p>
<ul>
<li>파라미터 있는 로그 (필수)</li>
<li>안정적 워크플로우 (권장)</li>
<li>분석가 피드백 루프 (필수)</li>
</ul>
<p><strong>실패 위험:</strong></p>
<ul>
<li>파라미터 없는데 억지로 적용</li>
<li>False Positive 무시하고 방치</li>
<li>재학습 주기 미설정</li>
</ul>
<p><strong>5. 2010년 vs 2024년</strong></p>
<p><strong>변하지 않은 것:</strong></p>
<ul>
<li>해석 가능성의 중요성</li>
<li>워크플로우 구조의 선형성</li>
<li>운영자 부담 경감 필요성</li>
</ul>
<p><strong>변한 것:</strong></p>
<ul>
<li>딥러닝 도구 등장 (DeepLog 등)</li>
<li>클라우드 네이티브 환경 (더 복잡)</li>
<li>로그 규모 폭증 (수억 줄)</li>
</ul>
<p>→ 근본 개념은 여전히 유효, 도구는 진화 중</p>
<p><strong>다음 궁금증 (Day 5 Preview):</strong></p>
<ul>
<li>이 논문의 교훈을 종합하면?</li>
<li>SOC 실무에 어떻게 체계적으로 적용할까?</li>
<li>어떤 프레임워크와 연계 가능한가?</li>
<li>면접에서 어떻게 설명할까?</li>
</ul>
<hr>
<p><strong>Day 4 종료</strong><br>
내일은 최종 결론과 SOC 실무 적용 전략을 정리해보자!</p>
<p>좋아! 마지막 Day 5 정리할게!</p>
<p>논문에서 Conclusion 부분이랑 전체적인 내용은 이미 다 있으니, 지금까지 4일간 분석한 내용을 바탕으로 <strong>SOC 실무 적용 중심</strong>으로 Day 5 작성할게!</p>
<hr>
<h1 id="research-review-mining-invariants-from-console-logs-for-system-problem-detection-4">Research Review: Mining Invariants from Console Logs for System Problem Detection<a hidden class="anchor" aria-hidden="true" href="#research-review-mining-invariants-from-console-logs-for-system-problem-detection-4">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2024.12.26<br>
<strong>Keywords:</strong> Log_Invariants, Anomaly_Detection, Execution_Flow, Linear_Relationships, Rule_Mining<br>
<strong>Source:</strong> USENIX ATC 2010 <a href="https://www.usenix.org/legacy/events/atc10/tech/full_papers/Lou.pdf">Paper Link</a></p>
</blockquote>
<hr>
<h2 id="day-5--conclusions-and-practical-implications">Day 5 – Conclusions and Practical Implications<a hidden class="anchor" aria-hidden="true" href="#day-5--conclusions-and-practical-implications">#</a></h2>
<p><em>(SOC 실무 적용 전략)</em></p>
<h3 id="1-연구-전체-요약">1. 연구 전체 요약<a hidden class="anchor" aria-hidden="true" href="#1-연구-전체-요약">#</a></h3>
<h4 id="a-5일간-학습-여정">A. 5일간 학습 여정<a hidden class="anchor" aria-hidden="true" href="#a-5일간-학습-여정">#</a></h4>
<pre tabindex="0"><code>Day 1: 문제 정의
  &#34;왜 블랙박스 통계 모델은 SOC에 부족한가?&#34;
  → 설명 가능성의 필요성

Day 2: 해법 설계
  &#34;어떻게 자동으로 불변성을 찾는가?&#34;
  → 4단계 파이프라인 (파싱-그룹핑-마이닝-탐지)

Day 3: 실전 검증
  &#34;실제로 효과가 있는가?&#34;
  → Hadoop 버그 발견, PCA 대비 우수

Day 4: 한계 인식
  &#34;언제 쓰면 안 되는가?&#34;
  → 파라미터 의존성, 선형 제약

Day 5: 실무 적용
  &#34;SOC에서 어떻게 쓸 것인가?&#34;
  → 종합 전략 수립
</code></pre><h4 id="b-핵심-발견-다이어그램">B. 핵심 발견 다이어그램<a hidden class="anchor" aria-hidden="true" href="#b-핵심-발견-다이어그램">#</a></h4>
<pre tabindex="0"><code>[비정형 로그]
    ↓
[파싱: 시그니처 + 파라미터 분리]
    ↓
[그룹핑: 동원 파라미터 자동 식별]
    ↓
[마이닝: 희소 정수 불변성 탐색]
    ↓
[불변성 집합]
    ↓
[이상 탐지 + 위반 불변성 명시]
    ↓
[SOC 분석가에게 즉시 대응 가능한 정보 제공]
</code></pre><hr>
<h3 id="2-이론적-기여-정리">2. 이론적 기여 정리<a hidden class="anchor" aria-hidden="true" href="#2-이론적-기여-정리">#</a></h3>
<h4 id="a-학술적-의의">A. 학술적 의의<a hidden class="anchor" aria-hidden="true" href="#a-학술적-의의">#</a></h4>
<table>
  <thead>
      <tr>
          <th>기여 영역</th>
          <th>내용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>해석 가능성</strong></td>
          <td>블랙박스 통계 모델의 한계 극복, 화이트박스 접근 제시</td>
      </tr>
      <tr>
          <td><strong>자동화</strong></td>
          <td>전문가 없이도 워크플로우 구조 자동 학습</td>
      </tr>
      <tr>
          <td><strong>실용성</strong></td>
          <td>실제 시스템에서 새로운 버그 발견 (Hadoop DFS 중복 복제)</td>
      </tr>
      <tr>
          <td><strong>확장성</strong></td>
          <td>MapReduce 기반 분산 처리로 대규모 로그 대응</td>
      </tr>
  </tbody>
</table>
<h4 id="b-로그-분석-패러다임-전환">B. 로그 분석 패러다임 전환<a hidden class="anchor" aria-hidden="true" href="#b-로그-분석-패러다임-전환">#</a></h4>
<p><strong>Before (2010년 이전):</strong></p>
<pre tabindex="0"><code>규칙 기반: 전문가 수동 작성 → 비용 높음
통계 학습: PCA, SVM → 설명 불가
</code></pre><p><strong>After (이 논문):</strong></p>
<pre tabindex="0"><code>자동 학습 + 해석 가능 = 실용적 이상탐지
</code></pre><p><strong>영향:</strong></p>
<ul>
<li>이후 DeepLog 등 후속 연구의 비교 기준</li>
<li>SIEM 벤더들의 설명 가능한 AI 기능 추가 동기 부여</li>
<li>SOC 분석가 교육에 워크플로우 분석 개념 도입</li>
</ul>
<hr>
<h3 id="3-soc-실무-적용-전략">3. SOC 실무 적용 전략<a hidden class="anchor" aria-hidden="true" href="#3-soc-실무-적용-전략">#</a></h3>
<h3 id="a-탐지-역량-강화">A. 탐지 역량 강화<a hidden class="anchor" aria-hidden="true" href="#a-탐지-역량-강화">#</a></h3>
<h4 id="1-명확한-워크플로우-시스템-우선-적용">1. 명확한 워크플로우 시스템 우선 적용<a hidden class="anchor" aria-hidden="true" href="#1-명확한-워크플로우-시스템-우선-적용">#</a></h4>
<table>
  <thead>
      <tr>
          <th>적용 영역</th>
          <th>구체적 방법</th>
          <th>기대 효과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>ETL 파이프라인</strong></td>
          <td>작업 ID 기반 불변성 학습</td>
          <td>데이터 누락/중복 즉시 탐지</td>
      </tr>
      <tr>
          <td><strong>배치 처리 시스템</strong></td>
          <td>Job ID 기반 시작-종료 매칭</td>
          <td>좀비 프로세스 자동 발견</td>
      </tr>
      <tr>
          <td><strong>백업 시스템</strong></td>
          <td>백업 세션 ID 기반 워크플로우 검증</td>
          <td>불완전 백업 조기 경보</td>
      </tr>
      <tr>
          <td><strong>프로비저닝 자동화</strong></td>
          <td>리소스 ID 추적으로 생성-삭제 균형 확인</td>
          <td>리소스 누수 방지</td>
      </tr>
  </tbody>
</table>
<p><strong>실전 예시: ETL 파이프라인</strong></p>
<pre tabindex="0"><code>학습된 불변성:
1. count(&#34;Extract started&#34;) = count(&#34;Load completed&#34;)
2. count(&#34;Transform error&#34;) + count(&#34;Load completed&#34;) = count(&#34;Extract started&#34;)

탐지 결과:
Extract: 1000건
Transform error: 50건
Load completed: 945건

→ 불변성 2 위반: 1000 ≠ 50 + 945
→ 5건의 데이터가 에러도 아닌데 사라짐
→ 즉시 조사 필요
</code></pre><h4 id="2-1차-필터로-활용">2. 1차 필터로 활용<a hidden class="anchor" aria-hidden="true" href="#2-1차-필터로-활용">#</a></h4>
<table>
  <thead>
      <tr>
          <th>탐지 계층</th>
          <th>도구</th>
          <th>역할</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>1차: 구조적 이상</strong></td>
          <td>불변성 기반</td>
          <td>명확한 워크플로우 위반 즉시 차단</td>
      </tr>
      <tr>
          <td><strong>2차: 패턴 이상</strong></td>
          <td>DeepLog 등</td>
          <td>미묘한 시퀀스 패턴 이상 탐지</td>
      </tr>
      <tr>
          <td><strong>3차: 수동 분석</strong></td>
          <td>SOC 분석가</td>
          <td>1차에서 제공한 불변성 위반 정보로 근본 원인 추적</td>
      </tr>
  </tbody>
</table>
<p><strong>통합 시나리오:</strong></p>
<pre tabindex="0"><code>1. 불변성 탐지: &#34;JVM 시작 100, 종료 95&#34; 
   → Ticket 자동 생성
   
2. DeepLog 탐지: &#34;비정상 로그 시퀀스&#34;
   → 불확실, 보류
   
3. 분석가 조사: 1번 티켓 우선 처리
   → 5개 JVM hang 확인
   → 2번도 같은 원인으로 판명
</code></pre><hr>
<h3 id="b-대응-역량-강화">B. 대응 역량 강화<a hidden class="anchor" aria-hidden="true" href="#b-대응-역량-강화">#</a></h3>
<h4 id="1-티켓-자동-생성-고도화">1. 티켓 자동 생성 고도화<a hidden class="anchor" aria-hidden="true" href="#1-티켓-자동-생성-고도화">#</a></h4>
<table>
  <thead>
      <tr>
          <th>기존 방식</th>
          <th>개선 방식</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>&ldquo;이상 탐지됨&rdquo;</td>
          <td>&ldquo;불변성 위반: JVM 시작 100, 종료 95&rdquo;</td>
      </tr>
      <tr>
          <td>심각도: ?</td>
          <td>심각도: HIGH (프로세스 누수)</td>
      </tr>
      <tr>
          <td>담당자: 수동 배정</td>
          <td>담당자: 자동 배정 (JVM 관리팀)</td>
      </tr>
      <tr>
          <td>조치: 로그 확인 필요</td>
          <td>조치: 5개 JVM 강제 종료 검토</td>
      </tr>
  </tbody>
</table>
<p><strong>티켓 템플릿 예시:</strong></p>
<pre tabindex="0"><code>제목: [자동탐지] JVM 프로세스 누수 의심
심각도: HIGH
탐지 시간: 2024-12-26 14:32:15

위반 불변성:
count(&#34;JVM spawned&#34;) = count(&#34;JVM exited&#34;)
실제: 100 ≠ 95

근본 원인 추정:
- 5개 JVM이 시작했으나 종료되지 않음
- 작업 할당은 정상 (count 일치 확인)
- 작업 할당 후 hang 추정

권장 조치:
1. ps aux | grep java 로 좀비 프로세스 확인
2. 해당 JVM stack dump 수집
3. 필요 시 kill -9 처리

관련 로그:
[자동 첨부]
</code></pre><h4 id="2-플레이북-자동-매핑">2. 플레이북 자동 매핑<a hidden class="anchor" aria-hidden="true" href="#2-플레이북-자동-매핑">#</a></h4>
<table>
  <thead>
      <tr>
          <th>위반 불변성</th>
          <th>매핑 플레이북</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>시작 ≠ 종료</td>
          <td>프로세스 누수 대응</td>
      </tr>
      <tr>
          <td>파일 열기 ≠ 닫기</td>
          <td>파일 핸들러 누수 대응</td>
      </tr>
      <tr>
          <td>요청 수신 ≠ 응답 전송</td>
          <td>응답 누락 대응</td>
      </tr>
      <tr>
          <td>데이터 수신 ≠ 삭제</td>
          <td>디스크 공간 관리</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="c-분석-역량-강화">C. 분석 역량 강화<a hidden class="anchor" aria-hidden="true" href="#c-분석-역량-강화">#</a></h3>
<h4 id="1-근본-원인-분석-가속화">1. 근본 원인 분석 가속화<a hidden class="anchor" aria-hidden="true" href="#1-근본-원인-분석-가속화">#</a></h4>
<p><strong>기존 분석 프로세스:</strong></p>
<pre tabindex="0"><code>1. 이상 알림 수신
2. 로그 전체 검색
3. 패턴 수동 파악
4. 가설 수립
5. 검증
→ 평균 2-4시간
</code></pre><p><strong>불변성 기반 프로세스:</strong></p>
<pre tabindex="0"><code>1. 이상 알림 + 위반 불변성 수신
2. 불변성 관련 로그만 필터링
3. 즉시 가설 확정
4. 검증
→ 평균 30분-1시간
</code></pre><p><strong>MTTD/MTTR 개선:</strong></p>
<ul>
<li>MTTD: 평균 50% 단축 (실시간 탐지)</li>
<li>MTTR: 평균 60% 단축 (즉시 원인 파악)</li>
</ul>
<h4 id="2-트렌드-분석">2. 트렌드 분석<a hidden class="anchor" aria-hidden="true" href="#2-트렌드-분석">#</a></h4>
<table>
  <thead>
      <tr>
          <th>분석 유형</th>
          <th>방법</th>
          <th>인사이트</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>빈도 분석</strong></td>
          <td>불변성별 위반 횟수 추적</td>
          <td>가장 불안정한 워크플로우 식별</td>
      </tr>
      <tr>
          <td><strong>시간대 분석</strong></td>
          <td>특정 시간대 위반 집중</td>
          <td>리소스 경쟁 시간대 파악</td>
      </tr>
      <tr>
          <td><strong>상관 분석</strong></td>
          <td>여러 불변성 동시 위반</td>
          <td>Cascading failure 패턴 발견</td>
      </tr>
  </tbody>
</table>
<p><strong>실전 예시:</strong></p>
<pre tabindex="0"><code>월간 리포트:
- &#34;JVM 시작=종료&#34; 위반: 237건 (전월 대비 +42%)
- 주로 금요일 오후 3-5시 집중
- &#34;Heartbeat 손실&#34; 불변성과 78% 동시 발생
→ 금요일 배치 작업 시간 조정 권고
</code></pre><hr>
<h3 id="4-프레임워크표준-연계">4. 프레임워크/표준 연계<a hidden class="anchor" aria-hidden="true" href="#4-프레임워크표준-연계">#</a></h3>
<h4 id="a-mitre-attck-연계">A. MITRE ATT&amp;CK 연계<a hidden class="anchor" aria-hidden="true" href="#a-mitre-attck-연계">#</a></h4>
<table>
  <thead>
      <tr>
          <th>ATT&amp;CK Tactic</th>
          <th>불변성 활용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Initial Access</strong></td>
          <td>로그인 시도 = 세션 시작 불일치 탐지</td>
      </tr>
      <tr>
          <td><strong>Execution</strong></td>
          <td>프로세스 실행 = 종료 균형 검증</td>
      </tr>
      <tr>
          <td><strong>Persistence</strong></td>
          <td>예정된 작업 생성 = 삭제 추적</td>
      </tr>
      <tr>
          <td><strong>Defense Evasion</strong></td>
          <td>로그 삭제 = 로그 생성 불균형</td>
      </tr>
      <tr>
          <td><strong>Credential Access</strong></td>
          <td>인증 시도 패턴 일관성 검증</td>
      </tr>
      <tr>
          <td><strong>Lateral Movement</strong></td>
          <td>네트워크 연결 시작 = 종료 매칭</td>
      </tr>
  </tbody>
</table>
<p><strong>적용 예시:</strong></p>
<pre tabindex="0"><code>ATT&amp;CK: T1078 (Valid Accounts)
불변성: count(&#34;로그인 성공&#34;) ≈ count(&#34;정상 업무 활동&#34;)

탐지:
로그인 성공: 1000건
업무 활동: 950건
→ 50건은 로그인만 하고 활동 없음
→ 계정 도용 의심
</code></pre><h4 id="b-cyber-kill-chain-연계">B. Cyber Kill Chain 연계<a hidden class="anchor" aria-hidden="true" href="#b-cyber-kill-chain-연계">#</a></h4>
<table>
  <thead>
      <tr>
          <th>Kill Chain 단계</th>
          <th>불변성 매핑</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Reconnaissance</strong></td>
          <td>포트 스캔 = 연결 시도 패턴 이상</td>
      </tr>
      <tr>
          <td><strong>Weaponization</strong></td>
          <td>파일 생성 = 실행 관계 검증</td>
      </tr>
      <tr>
          <td><strong>Delivery</strong></td>
          <td>이메일 수신 = 첨부파일 처리 균형</td>
      </tr>
      <tr>
          <td><strong>Exploitation</strong></td>
          <td>취약점 접근 = 정상 흐름 위반</td>
      </tr>
      <tr>
          <td><strong>Installation</strong></td>
          <td>파일 설치 = 프로세스 등록 일치</td>
      </tr>
      <tr>
          <td><strong>C2</strong></td>
          <td>외부 통신 = 내부 활동 상관관계</td>
      </tr>
      <tr>
          <td><strong>Actions</strong></td>
          <td>데이터 접근 = 전송 균형</td>
      </tr>
  </tbody>
</table>
<h4 id="c-nist-csf-연계">C. NIST CSF 연계<a hidden class="anchor" aria-hidden="true" href="#c-nist-csf-연계">#</a></h4>
<table>
  <thead>
      <tr>
          <th>NIST 기능</th>
          <th>불변성 활용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Identify</strong></td>
          <td>자산 등록 = 로그 출현 일치 검증</td>
      </tr>
      <tr>
          <td><strong>Protect</strong></td>
          <td>접근 제어 = 인증/인가 균형</td>
      </tr>
      <tr>
          <td><strong>Detect</strong></td>
          <td>불변성 위반 자동 탐지</td>
      </tr>
      <tr>
          <td><strong>Respond</strong></td>
          <td>위반 불변성 기반 플레이북 선택</td>
      </tr>
      <tr>
          <td><strong>Recover</strong></td>
          <td>복구 프로세스 완전성 검증</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="5-실전-체크리스트">5. 실전 체크리스트<a hidden class="anchor" aria-hidden="true" href="#5-실전-체크리스트">#</a></h3>
<h4 id="a-도입-전-준비사항">A. 도입 전 준비사항<a hidden class="anchor" aria-hidden="true" href="#a-도입-전-준비사항">#</a></h4>
<p><strong>시스템 요구사항:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 로그에 요청ID/작업ID/세션ID 등 파라미터 포함</li>
<li><input disabled="" type="checkbox"> 파라미터 값이 최소 3글자 이상</li>
<li><input disabled="" type="checkbox"> 메시지 타입 수가 1,000개 이하</li>
<li><input disabled="" type="checkbox"> 워크플로우가 상대적으로 안정적</li>
</ul>
<p><strong>조직 준비도:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> SOC 분석가가 불변성 개념 이해</li>
<li><input disabled="" type="checkbox"> 개발팀과 로그 포맷 협의 가능</li>
<li><input disabled="" type="checkbox"> False Positive 피드백 루프 구축 가능</li>
<li><input disabled="" type="checkbox"> 정기 재학습 프로세스 수립 가능</li>
</ul>
<h4 id="b-단계별-실행-체크리스트">B. 단계별 실행 체크리스트<a hidden class="anchor" aria-hidden="true" href="#b-단계별-실행-체크리스트">#</a></h4>
<p><strong>Phase 1: 파일럿 (Week 1-8)</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Week 1-2: 대상 시스템 선정 (명확한 워크플로우)</li>
<li><input disabled="" type="checkbox"> Week 3-4: 로그 수집 및 파라미터 그룹 식별</li>
<li><input disabled="" type="checkbox"> Week 5-6: 불변성 학습 및 수동 검증</li>
<li><input disabled="" type="checkbox"> Week 7-8: 파일럿 탐지 및 결과 분석</li>
</ul>
<p><strong>Phase 2: 확장 (Week 9-24)</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Week 9-12: 3-5개 시스템 추가 적용</li>
<li><input disabled="" type="checkbox"> Week 13-16: False Positive 화이트리스트 구축</li>
<li><input disabled="" type="checkbox"> Week 17-20: SIEM 연동 및 자동 티켓팅</li>
<li><input disabled="" type="checkbox"> Week 21-24: 분석가 교육 및 플레이북 작성</li>
</ul>
<p><strong>Phase 3: 최적화 (Week 25-52)</strong></p>
<ul>
<li><input disabled="" type="checkbox"> DeepLog 하이브리드 테스트</li>
<li><input disabled="" type="checkbox"> 자동 재학습 파이프라인 구축</li>
<li><input disabled="" type="checkbox"> MTTD/MTTR 메트릭 추적</li>
<li><input disabled="" type="checkbox"> 월간/분기 효과 리포트 작성</li>
</ul>
<h4 id="c-성공-지표">C. 성공 지표<a hidden class="anchor" aria-hidden="true" href="#c-성공-지표">#</a></h4>
<p><strong>정량적 지표:</strong></p>
<ul>
<li>MTTD 50% 이상 단축</li>
<li>MTTR 40% 이상 단축</li>
<li>False Positive Rate &lt; 5%</li>
<li>분석가 1인당 처리 티켓 수 30% 증가</li>
</ul>
<p><strong>정성적 지표:</strong></p>
<ul>
<li>분석가가 근본 원인을 즉시 이해</li>
<li>티켓 우선순위 결정 시간 단축</li>
<li>에스컬레이션 비율 감소</li>
</ul>
<hr>
<h3 id="6-5일간-리뷰-종합">6. 5일간 리뷰 종합<a hidden class="anchor" aria-hidden="true" href="#6-5일간-리뷰-종합">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Day</th>
          <th>주제</th>
          <th>핵심 학습 내용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Day 1</strong></td>
          <td>연구 동기 및 배경</td>
          <td>블랙박스 모델의 한계, 해석 가능성의 필요성</td>
      </tr>
      <tr>
          <td><strong>Day 2</strong></td>
          <td>방법론 설계</td>
          <td>4단계 파이프라인, 희소 정수 불변성 탐색 알고리즘</td>
      </tr>
      <tr>
          <td><strong>Day 3</strong></td>
          <td>실증 결과</td>
          <td>Hadoop 버그 발견, PCA 대비 설명력 우위</td>
      </tr>
      <tr>
          <td><strong>Day 4</strong></td>
          <td>한계 및 영향</td>
          <td>파라미터 의존성, 900회 인용, 후속 연구 촉발</td>
      </tr>
      <tr>
          <td><strong>Day 5</strong></td>
          <td>실무 적용</td>
          <td>SOC 통합 전략, 프레임워크 연계, 단계별 체크리스트</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="7-최종-개인-인사이트">7. 최종 개인 인사이트<a hidden class="anchor" aria-hidden="true" href="#7-최종-개인-인사이트">#</a></h3>
<h4 id="a-이-논문이-나의-soc-역량에-기여한-점">A. 이 논문이 나의 SOC 역량에 기여한 점<a hidden class="anchor" aria-hidden="true" href="#a-이-논문이-나의-soc-역량에-기여한-점">#</a></h4>
<p><strong>1. 해석 가능한 AI의 중요성 체감</strong></p>
<p>SOC는 단순히 &ldquo;이상하다&quot;를 넘어 <strong>&ldquo;왜 이상한지, 어떻게 대응할지&rdquo;</strong> 를 알아야 한다. 이 논문은 2010년에 이미 XAI의 핵심을 구현했다.</p>
<p><strong>2. DeepLog과의 상호보완 전략 수립</strong></p>
<p>DeepLog 먼저 공부하고 이 논문을 읽으니:</p>
<ul>
<li>DeepLog: 복잡한 패턴, 높은 탐지율</li>
<li>Invariants: 명확한 워크플로우, 즉시 설명 가능</li>
</ul>
<p>→ 둘을 <strong>언제, 어떻게</strong> 섞어 쓸지 명확해짐</p>
<p><strong>3. 로그 설계의 중요성 인식</strong></p>
<p>&ldquo;좋은 로그&quot;의 조건:</p>
<ul>
<li>파라미터 명시적 포함</li>
<li>일관된 포맷</li>
<li>프로그램 변수 ID 노출</li>
</ul>
<p>→ 개발팀과 협업 시 로그 설계 권고 가능</p>
<p><strong>4. 단계적 도입 전략 확보</strong></p>
<p>무작정 &ldquo;AI 도입&quot;이 아니라:</p>
<ol>
<li>파일럿으로 검증</li>
<li>False Positive 학습</li>
<li>점진적 확장</li>
</ol>
<p>→ 실패 위험 최소화</p>
<hr>
<h4 id="c-다음-학습-방향">C. 다음 학습 방향<a hidden class="anchor" aria-hidden="true" href="#c-다음-학습-방향">#</a></h4>
<p><strong>1. 후속 논문 읽기</strong></p>
<ul>
<li>DeepLog과 비교 심화</li>
<li>LogAnomaly: 불변성 + 딥러닝 통합 사례</li>
</ul>
<p><strong>2. 실습 프로젝트</strong></p>
<ul>
<li>작은 배치 시스템 로그로 불변성 마이닝</li>
<li>파라미터 그룹핑 알고리즘 직접 구현</li>
</ul>
<p><strong>3. SOC 도구 연계</strong></p>
<ul>
<li>Splunk/ELK에 불변성 체크 규칙 추가</li>
<li>Grafana 대시보드로 불변성 위반 시각화</li>
</ul>
<p><strong>4. 프레임워크 학습</strong></p>
<ul>
<li>MITRE ATT&amp;CK에 불변성 매핑 확장</li>
<li>NIST CSF의 Detect 기능에 통합 방안 연구</li>
</ul>
<hr>
<h3 id="8-최종-결론">8. 최종 결론<a hidden class="anchor" aria-hidden="true" href="#8-최종-결론">#</a></h3>
<h4 id="a-이론적-완결성">A. 이론적 완결성<a hidden class="anchor" aria-hidden="true" href="#a-이론적-완결성">#</a></h4>
<p>이 논문은:</p>
<ul>
<li>명확한 문제 정의</li>
<li>수학적으로 엄밀한 해법</li>
<li>실전 검증</li>
<li>솔직한 한계 인정</li>
</ul>
<p>모든 요소를 갖춘 <strong>완결된 연구</strong></p>
<h4 id="b-실무적-가치">B. 실무적 가치<a hidden class="anchor" aria-hidden="true" href="#b-실무적-가치">#</a></h4>
<p><strong>즉시 적용 가능:</strong></p>
<ul>
<li>파라미터 그룹핑 알고리즘</li>
<li>불변성 탐색 방법</li>
<li>False Positive 대응 전략</li>
</ul>
<p><strong>장기 전략:</strong></p>
<ul>
<li>DeepLog 하이브리드</li>
<li>SIEM 통합</li>
<li>지속적 개선</li>
</ul>
<h4 id="c-soc-분석가로서의-다짐">C. SOC 분석가로서의 다짐<a hidden class="anchor" aria-hidden="true" href="#c-soc-분석가로서의-다짐">#</a></h4>
<p><strong>단순 도구 사용자가 아닌, 원리 이해자:</strong></p>
<ul>
<li>&ldquo;이 도구는 왜 작동하는가?&rdquo;</li>
<li>&ldquo;언제 쓰고 언제 안 쓸 것인가?&rdquo;</li>
<li>&ldquo;어떻게 개선할 것인가?&rdquo;</li>
</ul>
<p><strong>이론과 실무의 균형:</strong></p>
<ul>
<li>논문으로 근본 원리 학습</li>
<li>실습으로 체득</li>
<li>실무에 적용하며 검증</li>
</ul>
<hr>
<p><strong>5일간 리뷰 완료</strong></p>
<p>이 논문을 통해:</p>
<ul>
<li>로그 분석의 본질 이해</li>
<li>DeepLog과의 차별점 파악</li>
<li>SOC 실무 적용 전략 수립</li>
</ul>
<p>다음 논문에서는 이 지식을 기반으로 더 깊이 파고들자!</p>
<hr>
<p><strong>전체 리뷰 종료</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/log-invariants/">Log-Invariants</a></li>
      <li><a href="http://localhost:1313/tags/anomaly-detection/">Anomaly-Detection</a></li>
      <li><a href="http://localhost:1313/tags/execution-flow/">Execution-Flow</a></li>
      <li><a href="http://localhost:1313/tags/linear-relationships/">Linear-Relationships</a></li>
      <li><a href="http://localhost:1313/tags/rule-mining/">Rule-Mining</a></li>
      <li><a href="http://localhost:1313/tags/usenix-atc/">USENIX-ATC</a></li>
      <li><a href="http://localhost:1313/tags/explainable-ai/">Explainable-AI</a></li>
      <li><a href="http://localhost:1313/tags/hadoop-security/">Hadoop-Security</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">HJ&#39;s Security Note</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
