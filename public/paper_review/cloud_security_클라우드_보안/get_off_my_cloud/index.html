<!DOCTYPE html>
<html lang="ko" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Hey, You, Get Off of My Cloud: Exploring Information Leakage in Third-Party Compute Clouds | HJ&#39;s Security Note</title>
<meta name="keywords" content="클라우드보안, 측면채널공격, Co-residency, Prime&#43;Probe, 멀티테넌시, 캐시공격">
<meta name="description" content="클라우드 환경에서 하이퍼바이저 격리의 한계를 실증하고, 공유 CPU 캐시를 이용한 측면 채널 공격으로 암호화 키를 추출한 클라우드 보안의 전환점이 된 연구">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/paper_review/cloud_security_%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C_%EB%B3%B4%EC%95%88/get_off_my_cloud/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css" integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/paper_review/cloud_security_%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C_%EB%B3%B4%EC%95%88/get_off_my_cloud/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="HJ&#39;s Security Note (Alt + H)">HJ&#39;s Security Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="소개">
                    <span>소개</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/daily-logs/" title="Daily-Logs">
                    <span>일일 로그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/" title="프로젝트">
                    <span>프로젝트</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/cyber-law-study/" title="Cyber-Law-Study">
                    <span>보안법 공부</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/security-issues-analysis/" title="Security-Issues-Analysis">
                    <span>보안 시사 분석</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>태그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/paper-review/" title="Paper-Review">
                    <span>논문 리뷰</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">홈</a>&nbsp;»&nbsp;<a href="http://localhost:1313/paper_review/">논문 리뷰</a></div>
    <h1 class="post-title entry-hint-parent">
      Hey, You, Get Off of My Cloud: Exploring Information Leakage in Third-Party Compute Clouds
    </h1>
    <div class="post-meta"><span title='2025-12-01 00:00:00 +0000 UTC'>2025년 12월 1일</span>

</div>
  </header> 
  <div class="post-content"><h1 id="research-review-hey-you-get-off-of-my-cloud-exploring-information-leakage-in-third-party-compute-clouds">Research Review: Hey, You, Get Off of My Cloud: Exploring Information Leakage in Third-Party Compute Clouds<a hidden class="anchor" aria-hidden="true" href="#research-review-hey-you-get-off-of-my-cloud-exploring-information-leakage-in-third-party-compute-clouds">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2025.12.01
<strong>Keywords:</strong> Cross-Tenant, Side-Channel_Attack, Hypervisor_Isolation, Multi-tenancy, Co-residency
<strong>Source:</strong> ACM CCS 2009 (Computer and Communications Security) <a href="https://rist.tech.cornell.edu/papers/cloudsec.pdf">Full Text Link</a></p>
</blockquote>
<hr>
<h2 id="day-1--research-context--motivation">Day 1 – Research Context &amp; Motivation<a hidden class="anchor" aria-hidden="true" href="#day-1--research-context--motivation">#</a></h2>
<p><em>(클라우드 다중 테넌트 환경에서의 격리(Isolation) 붕괴 위협)</em></p>
<h3 id="1-연구-배경-클라우드-격리의-약속과-신뢰-문제">1. 연구 배경: 클라우드 격리의 약속과 신뢰 문제<a hidden class="anchor" aria-hidden="true" href="#1-연구-배경-클라우드-격리의-약속과-신뢰-문제">#</a></h3>
<ul>
<li><strong>다중 테넌트 환경 (Multi-tenancy):</strong> 클라우드 컴퓨팅의 핵심은 다수의 독립적인 고객(테넌트)이 동일한 물리적 인프라(CPU, RAM, 네트워크)를 공유하며 리소스를 효율적으로 사용하는 데 있습니다.</li>
<li><strong>격리 원칙 (Isolation Principle):</strong> 클라우드 서비스 제공자(CSP)는 하이퍼바이저(Hypervisor)를 통해 각 고객의 가상 머신(VM)이 완벽하게 분리되어 상호 간섭이 불가능함을 보장했습니다. 이 <strong>가상화 기반 격리</strong>가 클라우드 보안의 근본적인 신뢰 요소였습니다.</li>
<li><strong>연구 문제의식:</strong> 이처럼 강력하게 보장된 논리적 격리에도 불구하고, <strong>공유되는 물리적 자원</strong>을 통해 악의적인 테넌트가 다른 테넌트의 정보를 엿볼 수 있는 <strong>근본적인 위협</strong>이 존재하는가?</li>
</ul>
<h3 id="2-핵심-위협-측면-채널-공격-side-channel-attack">2. 핵심 위협: 측면 채널 공격 (Side-Channel Attack)<a hidden class="anchor" aria-hidden="true" href="#2-핵심-위협-측면-채널-공격-side-channel-attack">#</a></h3>
<p>본 논문은 측면 채널 공격(Side-Channel Attack)을 통해 논리적 격리의 취약성을 입증합니다.</p>
<ul>
<li><strong>정의:</strong> 시스템의 주요 입출력 경로(Main Channel)가 아닌, 물리적 구현 과정에서 발생하는 부수적인 정보(Side Channel)를 측정하여 데이터를 유출하는 공격 기법.</li>
<li><strong>클라우드에서의 측면 채널:</strong> 공격자가 물리적으로 공유되는 CPU의 캐시(CPU Cache)나 RAM 접근 시간을 측정하여, 같은 물리 서버에 있는 타겟 VM의 암호화 작업(Cryptographic Operation) 패턴이나 입력 행위를 모니터링할 수 있음을 제시합니다.</li>
</ul>
<h3 id="3-공격의-2단계-구조-co-residency와-leakage">3. 공격의 2단계 구조: Co-residency와 Leakage<a hidden class="anchor" aria-hidden="true" href="#3-공격의-2단계-구조-co-residency와-leakage">#</a></h3>
<p>본 연구는 공격 성공을 두 가지 단계로 분리하여 정의합니다.</p>
<h4 id="a-co-residency-detection-동일-물리-서버-확인">A. Co-residency Detection (동일 물리 서버 확인)<a hidden class="anchor" aria-hidden="true" href="#a-co-residency-detection-동일-물리-서버-확인">#</a></h4>
<ul>
<li><strong>목표:</strong> 공격자 VM이 타겟 VM과 <strong>동일한 물리적 서버(Physical Host)</strong> 위에서 실행되고 있는지 확인하는 것.</li>
<li><strong>기술:</strong> 공격자가 클라우드 환경에서 VM을 생성할 때, 네트워크 레이턴시(지연 시간) 분석이나, CPU의 <strong>캐시 라인(Cache Line)</strong> 경쟁을 유발하여 응답 시간을 측정하는 방식으로 타겟 VM의 &lsquo;물리적 이웃&rsquo; 여부를 확인합니다.</li>
</ul>
<h4 id="b-cross-vm-information-leakage-정보-유출">B. Cross-VM Information Leakage (정보 유출)<a hidden class="anchor" aria-hidden="true" href="#b-cross-vm-information-leakage-정보-유출">#</a></h4>
<ul>
<li><strong>목표:</strong> Co-residency가 확인된 후, <strong>공유 캐시</strong>의 사용 패턴을 측정하여 타겟 VM 내부의 민감한 정보(예: 암호화 키, 사용자 입력)를 추론하는 것.</li>
</ul>
<h3 id="4-연구의-주요-기여-및-파급-효과">4. 연구의 주요 기여 및 파급 효과<a hidden class="anchor" aria-hidden="true" href="#4-연구의-주요-기여-및-파급-효과">#</a></h3>
<ul>
<li><strong>클라우드 보안 신뢰성 재평가:</strong> CSP가 보장하는 하이퍼바이저 격리가 완벽하지 않으며, <strong>공유 자원 관리</strong>가 클라우드 보안의 가장 취약한 경계임을 입증했습니다.</li>
<li><strong>산업적 변화 촉발:</strong> 이 연구는 클라우드 벤더들에게 하이퍼바이저 설계, VM 배치 전략(VM Scheduling), 그리고 캐시 자원 관리 방식을 근본적으로 재고하도록 촉발한 전환점(Turning Point)이 되었습니다.</li>
</ul>
<h3 id="5-개인-인사이트-personal-insight">5. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#5-개인-인사이트-personal-insight">#</a></h3>
<p>클라우드 보안의 복잡성은 Zero Trust나 IAM(접근 통제) 같은 논리적 문제뿐 아니라, <strong>물리적인 CPU 레벨의 격리 문제</strong>에서 기인한다는 점을 명확히 이해해야 한다. 이 논문은 논리적 방어가 아무리 잘 되어 있어도, 물리적 자원을 공유하는 한 <strong>항상 &lsquo;측면&rsquo;이 뚫릴 수 있다</strong>는 근본적인 경고를 담고 있다. Day 1의 목표는 클라우드 보안의 초점이 API 관리를 넘어 &lsquo;하드웨어 레벨의 심층 방어&rsquo;까지 확장되어야 함을 확인하는 것이다.</p>
<h1 id="research-review-hey-you-get-off-of-my-cloud-exploring-information-leakage-in-third-party-compute-clouds-1">Research Review: Hey, You, Get Off of My Cloud: Exploring Information Leakage in Third-Party Compute Clouds<a hidden class="anchor" aria-hidden="true" href="#research-review-hey-you-get-off-of-my-cloud-exploring-information-leakage-in-third-party-compute-clouds-1">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2025.12.02
<strong>Keywords:</strong> Co-residency_Detection, Cache_Side_Channel, Prime+Probe, Cloud_Cartography
<strong>Source:</strong> ACM CCS 2009 (Computer and Communications Security) <a href="https://rist.tech.cornell.edu/papers/cloudsec.pdf">Full Text Link</a></p>
</blockquote>
<hr>
<h2 id="day-2--core-attack-mechanism-공격-핵심-메커니즘">Day 2 – Core Attack Mechanism (공격 핵심 메커니즘)<a hidden class="anchor" aria-hidden="true" href="#day-2--core-attack-mechanism-공격-핵심-메커니즘">#</a></h2>
<p><em>(공격 성공의 두 단계: Co-residency 확보 및 Side-Channel 이용)</em></p>
<h3 id="1-공격-모델-및-가정-threat-model">1. 공격 모델 및 가정 (Threat Model)<a hidden class="anchor" aria-hidden="true" href="#1-공격-모델-및-가정-threat-model">#</a></h3>
<p>본 논문은 매우 현실적인 공격 모델을 사용한다.</p>
<ul>
<li><strong>공격자 위치:</strong> 악의적인 행위자가 CSP에 등록된 일반 고객(다른 테넌트)이다.</li>
<li><strong>공격 목표:</strong> 타겟 VM과 동일한 물리적 서버에 VM을 배치하고, 공유되는 물리 자원을 이용해 정보를 유출한다.</li>
<li><strong>제한 사항:</strong> 공격자는 하이퍼바이저나 VM 모니터의 취약점을 이용하지 않으며, CSP의 관리자 권한을 획득하지 않는다. <strong>오직 정상적인 클라우드 API 호출 및 자원 측정</strong>만을 이용한다.</li>
</ul>
<h3 id="2-단계-1-co-residency-detection-동일-물리-서버-확인">2. 단계 1: Co-residency Detection (동일 물리 서버 확인)<a hidden class="anchor" aria-hidden="true" href="#2-단계-1-co-residency-detection-동일-물리-서버-확인">#</a></h3>
<p>공격의 첫 번째이자 가장 어려운 단계는 타겟 VM과 <strong>물리적으로 동일한 호스트</strong>에 배치되는 것이다. 논문은 이를 위한 여러 기술을 제시한다.</p>
<h4 id="a-네트워크-근접성-분석-network-proximity">A. 네트워크 근접성 분석 (Network Proximity)<a hidden class="anchor" aria-hidden="true" href="#a-네트워크-근접성-분석-network-proximity">#</a></h4>
<ul>
<li><strong>원리:</strong> 동일 물리 서버에 있는 두 VM 간의 네트워크 왕복 시간(RTT)은 매우 짧고(일반적으로 수십 마이크로초, µs 이하), 외부 네트워크상의 VM과 비교하여 확연히 낮은 값을 보인다.</li>
<li><strong>활용:</strong> 공격자가 자신의 VM에서 타겟 VM으로 패킷을 보내 RTT를 측정하여 물리적 이웃 여부를 신속하게 판단한다.</li>
</ul>
<h4 id="b-클라우드-지도-제작-cloud-cartography">B. 클라우드 지도 제작 (Cloud Cartography)<a hidden class="anchor" aria-hidden="true" href="#b-클라우드-지도-제작-cloud-cartography">#</a></h4>
<ul>
<li><strong>기술:</strong> 공격자가 수많은 인스턴스를 실행하고 이들의 내부 IP 주소 및 배치 정보를 체계적으로 수집하여 <strong>클라우드 인프라의 내부 구조를 유추</strong>한다. (Amazon EC2의 경우, 특정 IP 주소 범위가 물리적 랙이나 서버 그룹과 관련됨을 파악)</li>
<li><strong>결과:</strong> 이 지도를 활용하여 타겟 VM 근처의 IP 범위를 예측하고 해당 범위에 집중적으로 인스턴스를 요청할 수 있게 된다.</li>
</ul>
<h4 id="c-배치-국소성-악용-placement-locality">C. 배치 국소성 악용 (Placement Locality)<a hidden class="anchor" aria-hidden="true" href="#c-배치-국소성-악용-placement-locality">#</a></h4>
<ul>
<li><strong>개념:</strong> CSP의 VM 스케줄러가 리소스 활용을 극대화하기 위해, 새로 켜지는 인스턴스를 기존 인스턴스 근처(동일 물리 서버)에 배치하는 경향이 있음을 악용한다. 이는 <strong>무차별 대입(Brute Force)</strong> 전략의 성공률을 높인다.</li>
</ul>
<h3 id="3-단계-2-cross-vm-information-leakage-vm-간-정보-유출">3. 단계 2: Cross-VM Information Leakage (VM 간 정보 유출)<a hidden class="anchor" aria-hidden="true" href="#3-단계-2-cross-vm-information-leakage-vm-간-정보-유출">#</a></h3>
<p>Co-residency가 확인되면, 공격자는 <strong>공유 CPU 캐시</strong>를 이용해 정보 유출 공격을 실행한다.</p>
<h4 id="a-캐시-기반-측면-채널-cache-based-side-channel">A. 캐시 기반 측면 채널 (Cache-based Side Channel)<a hidden class="anchor" aria-hidden="true" href="#a-캐시-기반-측면-채널-cache-based-side-channel">#</a></h4>
<ul>
<li><strong>공유 자원:</strong> 현대 CPU의 L2/L3 캐시(Cache)는 동일 물리 서버에서 실행되는 모든 VM이 공유하는 물리적 자원이다.</li>
<li><strong>원리:</strong> 캐시 접근 시간은 메모리 접근 시간보다 훨씬 빠르다. 공격자는 타겟 VM의 캐시 사용 패턴 변화를 측정하여, 타겟 VM 내부에서 어떤 연산이 일어나는지 추론한다.</li>
</ul>
<h4 id="b-primeprobe-기법-프라임프로브">B. Prime+Probe 기법 (프라임+프로브)<a hidden class="anchor" aria-hidden="true" href="#b-primeprobe-기법-프라임프로브">#</a></h4>
<p>이 논문에서 핵심적으로 사용된 기법이다.</p>
<ol>
<li><strong>Prime (점령):</strong> 공격자 VM이 공유 캐시의 특정 영역(Cache Set)을 자신의 데이터로 가득 채운다.</li>
<li><strong>Victim Access (타겟 연산):</strong> 타겟 VM이 암호화 연산(예: RSA, AES)을 수행한다. 이 과정에서 타겟이 사용하는 비밀 키(Secret Key)에 따라 메모리 접근 패턴이 결정되고, 이 패턴에 해당하는 캐시 라인이 공격자의 데이터를 <strong>축출(Evict)</strong> 시킨다.</li>
<li><strong>Probe (측정):</strong> 공격자가 자신이 Prime 했던 데이터를 다시 접근하여 걸린 시간을 측정한다.
<ul>
<li><strong>접근이 느린 경우:</strong> 타겟 VM이 캐시를 사용해 데이터를 축출했다는 의미 → 특정 연산(비밀 키에 관련된)이 일어났음을 추론.</li>
<li><strong>접근이 빠른 경우:</strong> 타겟 VM이 캐시를 사용하지 않았다는 의미.</li>
</ul>
</li>
</ol>
<ul>
<li><strong>공격 예시:</strong> 논문은 이 기법을 이용해 <strong>AES 암호화 키</strong>를 65밀리초(ms) 만에 추출할 수 있음을 실험적으로 증명했다.</li>
</ul>
<h3 id="4-개인-인사이트-personal-insight">4. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#4-개인-인사이트-personal-insight">#</a></h3>
<p>Day 2 분석을 통해, 클라우드 환경에서 논리적 방어벽(Hypervisor)이 완벽하게 작동하더라도 <strong>물리적 공유 자원</strong>이 존재하면 격리가 붕괴될 수 있다는 점을 실감했다. 이 논문 이후 CSP들이 <strong>VM 배치 알고리즘</strong>과 <strong>하드웨어 캐시 관리</strong>에 막대한 투자를 하게 된 배경을 이해할 수 있었다. 클라우드 보안만의 관점을 넘어서 보안 컨설팅 시, 하드웨어 레벨의 보안 보증(Hardware-Assisted Security)을 확인하는 것의 중요성을 인지해야 한다.</p>
<hr>
<h1 id="research-review-hey-you-get-off-of-my-cloud-experimental-validation-and-quantification">Research Review: Hey, You, Get Off of My Cloud: Experimental Validation and Quantification<a hidden class="anchor" aria-hidden="true" href="#research-review-hey-you-get-off-of-my-cloud-experimental-validation-and-quantification">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2025.12.03
<strong>Focus:</strong> Experimental Setup, Co-residency Success Rate, and Information Leakage Quantification
<strong>Source:</strong> ACM CCS 2009 (Computer and Communications Security) <a href="https://rist.tech.cornell.edu/papers/cloudsec.pdf">Full Text Link</a></p>
</blockquote>
<hr>
<h2 id="day-3--experimental-validation-and-quantification">Day 3 – Experimental Validation and Quantification<a hidden class="anchor" aria-hidden="true" href="#day-3--experimental-validation-and-quantification">#</a></h2>
<p><em>(Amazon EC2 환경에서의 실제 공격 실증 및 결과 분석)</em></p>
<h3 id="1-실험-환경-및-목표-experimental-setup-and-targets">1. 실험 환경 및 목표 (Experimental Setup and Targets)<a hidden class="anchor" aria-hidden="true" href="#1-실험-환경-및-목표-experimental-setup-and-targets">#</a></h3>
<ul>
<li><strong>테스트 환경:</strong> 초기 <strong>Amazon EC2</strong> 환경을 대상으로 실증하였다. 이는 실험 결과의 파급력을 극대화하기 위함이었다.</li>
<li><strong>공격 모델:</strong> 공격자는 일반 고객 VM 자격으로, 하이퍼바이저 취약점 없이 정상적인 클라우드 API 호출 및 자원 측정만을 이용하였다.</li>
<li><strong>타겟 애플리케이션:</strong> 논문은 두 가지 주요 목표를 설정하여 정보 유출을 실증하였다.
<ol>
<li><strong>Linux 커널 함수:</strong> 타겟 VM의 커널 내부 루틴 접근 패턴 모니터링.</li>
<li><strong>암호화 라이브러리 (GnuPG):</strong> <strong>AES</strong> 및 <strong>RSA</strong> 암호화 연산 중 발생하는 캐시 접근 패턴을 모니터링하여 비밀 키를 추출하는 것이 최종 목표였다.</li>
</ol>
</li>
</ul>
<h3 id="2-co-residency-detection의-성공률-phase-1-results">2. Co-residency Detection의 성공률 (Phase 1 Results)<a hidden class="anchor" aria-hidden="true" href="#2-co-residency-detection의-성공률-phase-1-results">#</a></h3>
<p>공격자가 타겟 VM과 동일한 물리적 호스트에 배치되는 것이 현실적으로 가능함을 입증하였다.</p>
<ul>
<li><strong>네트워크 근접성 (RTT) 분석:</strong>
<ul>
<li><strong>결과:</strong> 공격자 VM과 타겟 VM 간의 네트워크 왕복 시간(RTT)이 <strong>100µs (마이크로초) 이하</strong>일 경우, 동일 물리 서버에 위치할 확률이 90% 이상임을 확인하였다.</li>
<li><strong>활용:</strong> 이 낮은 RTT 값은 클라우드 카르토그래피(Cloud Cartography)의 핵심 데이터로 사용되었으며, 타겟의 물리적 위치를 효과적으로 핑거프린팅할 수 있었다.</li>
</ul>
</li>
<li><strong>배치 성공률:</strong> <strong>클라우드 카르토그래피 기법</strong>을 활용하여 타겟 근처의 IP 범위를 공략했을 때, 무작위 대입 대비 <strong>배치 성공률을 유의미하게 향상</strong>시킬 수 있음을 입증하였다.</li>
</ul>
<h3 id="3-정보-유출의-정량화-quantification-of-information-leakage---phase-2-results">3. 정보 유출의 정량화 (Quantification of Information Leakage - Phase 2 Results)<a hidden class="anchor" aria-hidden="true" href="#3-정보-유출의-정량화-quantification-of-information-leakage---phase-2-results">#</a></h3>
<p>가장 중요한 실험 결과는 <strong>Prime+Probe</strong> 기법을 통해 <strong>암호화 키</strong>와 같은 민감한 정보를 실제로 추출하는 데 성공했다는 점이다.</p>
<ul>
<li><strong>AES 암호화 키 유출:</strong>
<ul>
<li><strong>기술:</strong> AES 알고리즘이 내부적으로 사용하는 <strong>S-Box (Substitution Box)</strong> 룩업 테이블 접근 패턴을 모니터링했다.</li>
<li><strong>결과:</strong> 단일 AES 암호화 연산에서 발생하는 캐시 흔적을 분석하여, <strong>AES 비밀 키의 일부 비트</strong>를 성공적으로 추출하였으며, 65밀리초(ms)라는 매우 짧은 시간 내에 유효한 데이터를 획득하였다.</li>
</ul>
</li>
<li><strong>RSA/GnuPG 키 유출:</strong>
<ul>
<li><strong>기술:</strong> RSA의 지수 연산(Exponentiation) 과정 중 발생하는 캐시 사용 패턴을 측정하였다.</li>
<li><strong>결과:</strong> 타겟의 GnuPG 연산을 모니터링하여 <strong>키의 일부분</strong>을 성공적으로 유추해낼 수 있음을 입증하였다. 이는 추상적인 코드 테스트가 아닌, <strong>실제 상용 보안 소프트웨어</strong>를 대상으로 격리 붕괴가 발생했음을 의미한다.</li>
</ul>
</li>
</ul>
<h3 id="4-기술적-결론-및-시사점-technical-conclusion">4. 기술적 결론 및 시사점 (Technical Conclusion)<a hidden class="anchor" aria-hidden="true" href="#4-기술적-결론-및-시사점-technical-conclusion">#</a></h3>
<ul>
<li><strong>격리 실패의 원인:</strong> 논리적 격리(Hypervisor)는 완벽했지만, 물리적 자원 공유(CPU Cache, Timing)라는 낮은 레벨의 채널을 제어하는 데 실패했다.</li>
<li><strong>산업적 영향:</strong> 이 결과는 클라우드 벤더들에게 VM 배치 전략(Anti-Affinity Rules)을 강화하고, <strong>하드웨어 수준의 캐시 파티셔닝(Cache Partitioning)</strong> 기술을 도입하는 계기가 되었다. <strong>Timing Channel</strong>이 클라우드 보안의 주요 위협으로 공식 인정되는 전환점이 되었다.</li>
</ul>
<h3 id="5-개인-인사이트-personal-insight-1">5. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#5-개인-인사이트-personal-insight-1">#</a></h3>
<p>실험 결과를 통해 논리적 방어(Hypervisor)만으로는 물리적 공유 자원을 매개로 한 정보 유출을 완벽히 통제할 수 없다는 점이 명확히 입증되었습니다.</p>
<ul>
<li>
<p><strong>하드웨어의 취약성 검증</strong>: 이 공격은 소프트웨어 버그가 아닌, CPU 캐시의 물리적 아키텍처 자체의 설계적 특성을 악용한 것입니다. 이는 보안의 경계가 애플리케이션이나 네트워크 레이어를 넘어 실제 하드웨어 레벨까지 확장되어야 함을 증명합니다.</p>
</li>
<li>
<p><strong>실무적 함의</strong>: 클라우드 보안 진단 및 컨설팅 시, IAM 설정이나 네트워크 접근 제어 같은 논리적 방어만 확인할 것이 아니라, CSP가 **VM 간 Anti-Affinity Rules (특정 VM을 같은 서버에 배치하지 않는 규칙)**와 **하드웨어 기반 격리 기술(예: Intel CAT, AMD SEV)**을 얼마나 강력하게 적용하고 있는지 확인하는 것의 중요성이 이 논문을 통해 정량적으로 입증되었습니다.</p>
</li>
<li>
<p><strong>보안의 초점 이동</strong>: 공격자가 단 65ms 만에 민감 정보를 추출하는 데 성공했다는 점은 Timing Channel에 대한 모니터링 및 방어 기술 개발이 필수적임을 보여줍니다.</p>
</li>
</ul>
<h1 id="research-review-hey-you-get-off-of-my-cloud-limitations-and-industrial-response">Research Review: Hey, You, Get Off of My Cloud: Limitations and Industrial Response<a hidden class="anchor" aria-hidden="true" href="#research-review-hey-you-get-off-of-my-cloud-limitations-and-industrial-response">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2025.12.04
<strong>Keywords:</strong> Anti-Affinity, Cache_Partitioning, Hardware_Mitigation, Timing_Channel_Mitigation
<strong>Source:</strong> ACM CCS 2009 (Computer and Communications Security) <a href="https://rist.tech.cornell.edu/papers/cloudsec.pdf">Full Text Link</a></p>
</blockquote>
<hr>
<h2 id="day-4--limitations-and-industrial-response">Day 4 – Limitations and Industrial Response<a hidden class="anchor" aria-hidden="true" href="#day-4--limitations-and-industrial-response">#</a></h2>
<p><em>(연구의 한계점 및 클라우드 보안 아키텍처의 발전 방향)</em></p>
<h3 id="1-공격의-기술적-난이도-및-한계점-technical-limitations-of-the-attack">1. 공격의 기술적 난이도 및 한계점 (Technical Limitations of the Attack)<a hidden class="anchor" aria-hidden="true" href="#1-공격의-기술적-난이도-및-한계점-technical-limitations-of-the-attack">#</a></h3>
<p>본 논문의 공격 실증은 클라우드 보안 모델의 근본적인 취약성을 드러냈지만, 실제 공격자가 광범위하게 사용하기에는 다음과 같은 기술적 어려움이 있었습니다.</p>
<ul>
<li><strong>Co-residency 확보의 난이도:</strong> 공격의 필수 전제인 타겟 VM과의 <strong>Co-residency</strong>를 확보하는 과정이 무작위 인스턴스 실행에 의존적이었으며, CSP가 <strong>Anti-Affinity Rules</strong>을 도입한 이후에는 공격 성공 확률이 현저히 낮아졌습니다.</li>
<li><strong>고도의 노이즈 관리:</strong> 측면 채널 공격은 타이밍(Timing)에 매우 민감합니다. VM의 스케줄링 변화나 네트워크 혼잡 등 환경적 요인으로 인해 측정 노이즈(Noise)가 발생하기 쉬워, 실제 작동하는 익스플로잇 코드를 작성하는 것은 매우 까다로운 작업이었습니다.</li>
<li><strong>비확장성 (Lack of Portability):</strong> 공격 코드가 특정 CPU 아키텍처의 캐시 구조 및 타겟 라이브러리(GnuPG)의 메모리 접근 패턴에 의존적이었으므로, 다른 클라우드 환경이나 애플리케이션으로의 <strong>범용적인 확장</strong>이 어려웠습니다.</li>
</ul>
<h3 id="2-산업적-대응-및-클라우드-격리의-발전-industry-response-and-evolution">2. 산업적 대응 및 클라우드 격리의 발전 (Industry Response and Evolution)<a hidden class="anchor" aria-hidden="true" href="#2-산업적-대응-및-클라우드-격리의-발전-industry-response-and-evolution">#</a></h3>
<p>이 논문의 발표는 CSP들에게 하이퍼바이저 격리 외의 <strong>물리적 방어 기술</strong>에 투자하게 만드는 직접적인 계기가 되었습니다.</p>
<h4 id="21-vm-배치-전략-강화-anti-affinity-rules">2.1. VM 배치 전략 강화 (Anti-Affinity Rules)<a hidden class="anchor" aria-hidden="true" href="#21-vm-배치-전략-강화-anti-affinity-rules">#</a></h4>
<ul>
<li>CSP들은 <strong>Anti-Affinity Rules</strong>을 도입하여, 잠재적 위협이 될 수 있는 VM들이 같은 물리적 호스트에 배치되지 않도록 <strong>VM 스케줄링 정책</strong>을 강화하였습니다.</li>
<li>또한, 클라우드 카르토그래피(Cloud Cartography)와 같은 <strong>정보 수집 행위 자체</strong>를 탐지하고 차단하는 매커니즘이 도입되었습니다.</li>
</ul>
<h4 id="22-하드웨어-수준의-방어-기술-hardware-assisted-mitigation">2.2. 하드웨어 수준의 방어 기술 (Hardware-Assisted Mitigation)<a hidden class="anchor" aria-hidden="true" href="#22-하드웨어-수준의-방어-기술-hardware-assisted-mitigation">#</a></h4>
<p>측면 채널 공격을 근본적으로 막기 위해, 논리적 방어벽(Hypervisor) 대신 <strong>하드웨어 자체</strong>에 격리 기능을 추가하는 방향으로 발전했습니다.</p>
<ul>
<li>**캐시 파티셔닝 (Cache Partitioning): Intel CAT (Cache Allocation Technology)과 같은 기술을 활용하여 공유 L3 캐시 자원을 VM별로 할당하고 격리하여, 한 VM이 다른 VM의 캐시 접근에 영향을 주지 못하도록 통제합니다.</li>
<li>**메모리 암호화: AMD SEV (Secure Encrypted Virtualization)와 같은 기술을 통해 메모리 접근 시 데이터를 암호화하여, 하이퍼바이저나 다른 VM이 메모리 내용을 읽더라도 의미 있는 정보를 획득하지 못하도록 방어합니다.</li>
</ul>
<h4 id="23-타이밍-채널-완화-timing-channel-reduction">2.3. 타이밍 채널 완화 (Timing Channel Reduction)<a hidden class="anchor" aria-hidden="true" href="#23-타이밍-채널-완화-timing-channel-reduction">#</a></h4>
<ul>
<li><strong>노이즈 주입 (Noise Injection):</strong> 운영체제 및 하이퍼바이저 수준에서 CPU 타이밍 정보를 <strong>불규칙하게 만들어</strong> (Jitter), 공격자가 정확한 시간 측정을 통해 민감한 연산 패턴을 파악하는 것을 어렵게 만드는 기술들이 도입되었습니다.</li>
</ul>
<hr>
<h3 id="3-개인-인사이트-personal-insight">3. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#3-개인-인사이트-personal-insight">#</a></h3>
<p>본 논문은 <strong>클라우드 보안의 초점이 하드웨어 레벨의 심층 방어로 확장되어야 함</strong>을 강하게 주장하고 있습니다.</p>
<ul>
<li><strong>실무적 함의:</strong> 클라우드 보안 전문가로서 <strong>IAM이나 방화벽</strong> 같은 소프트웨어 통제는 물론, CSP가 **물리적 자원(캐시)**을 어떻게 관리하고 격리하는지에 대한 **보안 보증서(Security Assurance)**를 확인하는 것이 필수적인 지식이 되었음을 확인합니다.</li>
<li><strong>방어 전략의 변화:</strong> 논리적 방어가 무력화될 수 있다는 교훈을 바탕으로, 방어의 기준점을 **&ldquo;소프트웨어 오류 방지&rdquo;**에서 **&ldquo;물리적 자원 공유 통제&rdquo;**로 상향시켜야 합니다. 이 연구는 <strong>Anti-Affinity</strong> 및 <strong>하드웨어 기반 캐시 격리 기술</strong>이 왜 현대 클라우드 보안 아키텍처에서 가장 중요한 요소 중 하나가 되었는지를 이해하는 근거가 됩니다.</li>
</ul>
<h1 id="research-review-hey-you-get-off-of-my-cloud-conclusion-and-final-evaluation">Research Review: Hey, You, Get Off of My Cloud: Conclusion and Final Evaluation<a hidden class="anchor" aria-hidden="true" href="#research-review-hey-you-get-off-of-my-cloud-conclusion-and-final-evaluation">#</a></h1>
<blockquote>
<p><strong>Analyzed Date:</strong> 2025.12.05
<strong>Focus:</strong> Final Synthesis, Impact on Shared Responsibility Model, and Future Trajectory
<strong>Source:</strong> ACM CCS 2009 (Computer and Communications Security) <a href="https://rist.tech.cornell.edu/papers/cloudsec.pdf">Full Text Link</a></p>
</blockquote>
<hr>
<h2 id="day-5--conclusion-and-future-trajectory">Day 5 – Conclusion and Future Trajectory<a hidden class="anchor" aria-hidden="true" href="#day-5--conclusion-and-future-trajectory">#</a></h2>
<p><em>(연구 최종 결론, 공유 책임 모델에 미친 영향 및 미래적 함의)</em></p>
<h3 id="1-연구-최종-요약-및-평가-final-synthesis-and-evaluation">1. 연구 최종 요약 및 평가 (Final Synthesis and Evaluation)<a hidden class="anchor" aria-hidden="true" href="#1-연구-최종-요약-및-평가-final-synthesis-and-evaluation">#</a></h3>
<p>본 논문은 클라우드 컴퓨팅의 핵심 신뢰 요소인 <strong>하이퍼바이저 기반의 논리적 격리 모델</strong>이 <strong>물리적 자원 공유</strong>라는 근본적인 취약점에 의해 붕괴될 수 있음을 실증적으로 증명하였습니다.</p>
<ul>
<li><strong>핵심 증명:</strong> 악의적인 테넌트가 <strong>Co-residency</strong> 를 확보하고 <strong>공유 CPU 캐시</strong> 를 이용한 <strong>Prime+Probe 측면 채널 공격</strong> 을 통해 타겟 <strong>VM</strong> 의 암호화 키를 성공적으로 추출할 수 있음을 입증했습니다.</li>
<li><strong>연구 가치:</strong> 이 연구는 <strong>소프트웨어 버그</strong> 가 아닌, <strong>하드웨어 아키텍처</strong> 자체의 설계적 특성이 보안 위협이 될 수 있음을 최초로 명확히 보여주면서 클라우드 보안 역사에서 <strong>가장 중요한 전환점</strong> 중 하나로 평가됩니다.</li>
</ul>
<h3 id="2-클라우드-공유-책임-모델의-재정의-redefining-the-shared-responsibility-model">2. 클라우드 공유 책임 모델의 재정의 (Redefining the Shared Responsibility Model)<a hidden class="anchor" aria-hidden="true" href="#2-클라우드-공유-책임-모델의-재정의-redefining-the-shared-responsibility-model">#</a></h3>
<p>이 논문은 클라우드 서비스 제공자 (<strong>CSP</strong>) 와 고객 간의 보안 책임 경계인 <strong>공유 책임 모델</strong> 에 직접적인 영향을 미쳤습니다.</p>
<ul>
<li><strong>이전의 가정:</strong> <strong>CSP</strong> 는 <strong>&ldquo;클라우드의 보안 (Security of the Cloud)&rdquo;</strong> 을 책임지며, 이는 하이퍼바이저를 통한 <strong>VM</strong> 간의 완벽한 격리를 포함한다고 여겨졌습니다.</li>
<li><strong>논문 이후의 변화:</strong> 이 공격은 <strong>CSP</strong> 의 책임 영역이었던 <strong>&lsquo;물리적 인프라&rsquo;</strong> 내의 <strong>&lsquo;공유 캐시 관리&rsquo;</strong> 가 미흡했음을 드러냈습니다. 즉, <strong>CSP</strong> 는 단순한 <strong>VM</strong> 격리 보장을 넘어, <strong>타이밍 채널</strong> 및 <strong>하드웨어 자원의 간섭</strong> 으로부터 고객을 보호해야 하는 책임이 추가되었습니다.</li>
<li><strong>결과:</strong> <strong>CSP</strong> 들은 고객의 워크로드를 보호하기 위해 <strong>Anti-Affinity Rules</strong>, <strong>캐시 파티셔닝 (Intel CAT)</strong> 등 <strong>&ldquo;하드웨어 레벨의 보안 통제&rdquo;</strong> 기술을 강화하는 방향으로 책임 영역을 확장했습니다.</li>
</ul>
<h3 id="3-향후-연구-및-산업적-함의-future-trajectory-and-industrial-implication">3. 향후 연구 및 산업적 함의 (Future Trajectory and Industrial Implication)<a hidden class="anchor" aria-hidden="true" href="#3-향후-연구-및-산업적-함의-future-trajectory-and-industrial-implication">#</a></h3>
<p>이 연구 이후, 보안 연구는 측면 채널 공격을 넘어선 새로운 격리 위협과 방어 기술에 집중하고 있습니다.</p>
<ul>
<li><strong>잔여 문제 (Residual Issues):</strong> 메모리 버스 (<strong>Memory Bus</strong>), <strong>TLB (Translation Lookaside Buffer)</strong>, <strong>L1 캐시</strong> 등 <strong>CPU</strong> 의 다른 공유 자원을 이용한 측면 채널 공격이 지속적으로 연구되었으며, 이는 <strong>Spectre 및 Meltdown</strong> 과 같은 제로데이 취약점 연구의 기반이 되었습니다.</li>
<li><strong>하드웨어 루트 오브 트러스트 (Hardware Root of Trust):</strong> 향후 클라우드 보안은 <strong>VM 격리</strong> 뿐만 아니라, <strong>기밀 컴퓨팅 (Confidential Computing)</strong> 기술을 통해 데이터를 사용 중일 때조차 <strong>암호화된 상태</strong> 로 유지 (예: <strong>TEE, Trusted Execution Environment</strong>) 하여 측면 채널 공격으로부터의 유출 가능성을 근본적으로 차단하는 방향으로 나아가고 있습니다.</li>
</ul>
<hr>
<h3 id="4-개인-인사이트-personal-insight-1">4. 개인 인사이트 (Personal Insight)<a hidden class="anchor" aria-hidden="true" href="#4-개인-인사이트-personal-insight-1">#</a></h3>
<p><strong>&ldquo;Hey, You, Get Off of My Cloud&rdquo;</strong> 논문은 보안 아키텍트라면 반드시 이해해야 할 <strong>클라우드 보안의 근본 원리</strong> 를 담고 있습니다. 논문의 가장 큰 시사점은 다음과 같습니다.</p>
<ul>
<li><strong>보안의 심층적 이해:</strong> 이 논문 덕분에 클라우드 보안은 단순히 방화벽 설정이나 <strong>IAM</strong> 정책을 넘어, <strong>CPU 마이크로아키텍처</strong> 의 동작 방식까지 이해해야 하는 <strong>심층 방어 (Defense in Depth)</strong> 의 영역이 되었음을 깨닫습니다.</li>
<li><strong>실무적 판단 기준:</strong> 현재 클라우드 인프라의 안정성을 평가할 때, <strong>Anti-Affinity Rules</strong> 의 적용 여부, <strong>Intel CAT</strong> 과 같은 캐시 격리 기술의 사용 유무는 더 이상 선택 사항이 아니라, <strong>기본적인 보안 보증 (Security Assurance)</strong> 을 판단하는 결정적인 기준이 되었습니다. 이 논문은 우리가 클라우드를 선택하고 설계할 때 어떤 질문을 던져야 하는지에 대한 명확한 기준을 제시해 주었습니다.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EB%B3%B4%EC%95%88/">클라우드보안</a></li>
      <li><a href="http://localhost:1313/tags/%EC%B8%A1%EB%A9%B4%EC%B1%84%EB%84%90%EA%B3%B5%EA%B2%A9/">측면채널공격</a></li>
      <li><a href="http://localhost:1313/tags/co-residency/">Co-Residency</a></li>
      <li><a href="http://localhost:1313/tags/prime&#43;probe/">Prime&#43;Probe</a></li>
      <li><a href="http://localhost:1313/tags/%EB%A9%80%ED%8B%B0%ED%85%8C%EB%84%8C%EC%8B%9C/">멀티테넌시</a></li>
      <li><a href="http://localhost:1313/tags/%EC%BA%90%EC%8B%9C%EA%B3%B5%EA%B2%A9/">캐시공격</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">HJ&#39;s Security Note</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
