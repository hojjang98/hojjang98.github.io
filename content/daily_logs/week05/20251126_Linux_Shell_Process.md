---
title: "2025.11.26 (Day 23) Linux Shell 심화: I/O 제어, 정규식, 프로세스 관리"
date: 2025-11-26
draft: false
tags: ["Linux", "Shell", "정규식", "프로세스관리", "SK쉴더스루키즈"]
categories: ["daily-logs"]
summary: "리눅스 표준 입출력·리다이렉션·파이프, 정규식(grep/awk), 프로세스 관리 및 cron 자동화 실습"
---

# 📄 2025.11.26 (Day 23) [Linux Shell 심화: I/O 제어, 정규식, 프로세스 관리]

## 1. 핵심 개념 정리 (Concepts & Theory)

| # | 핵심 개념 | 간결한 설명 | 실무/보안 관점에서의 중요성 |
|:---:|:---|:---|:---|
| **1** | **표준 입출력 & Redirection** | 표준 입력(0), 표준 출력(1), 표준 에러(2)는 프로세스가 데이터를 주고받는 기본 통로입니다. `>`, `>>`, `2>&1` 등의 리다이렉션을 통해 데이터 흐름을 파일이나 다른 명령어로 재지정할 수 있습니다. | **로그 수집 및 분석**의 핵심입니다. 에러 로그를 분리 저장하거나(`2>error.log`), 로그를 실시간으로 모니터링하며 동시에 파일 저장(`tee`)하는 등 관제/사고 대응 시 필수적인 기술입니다. |
| **2** | **파이프(Pipe)** | 파이프(`\|`)는 한 명령어의 표준 출력을 다음 명령어의 표준 입력으로 직접 연결하는 매커니즘입니다. 중간 파일 없이 여러 명령어를 체인처럼 연결할 수 있습니다. | **대용량 로그 분석**에서 `grep`, `awk`, `sort`, `uniq` 등을 파이프로 연결하여 실시간 필터링/집계가 가능합니다. SOC에서 로그 스트림 처리 시 핵심 기술입니다. |
| **3** | **정규식(Regular Expression)** | 텍스트 패턴을 특수 문자(`^`, `$`, `.`, `*`, `[]`, `\{n,m\}` 등)로 표현하여 복잡한 문자열 검색 및 치환을 수행하는 문법입니다. `grep`, `sed`, `awk`에서 활용됩니다. | **침입 탐지**, **로그 분석**, **악성코드 시그니처 탐지**의 기반입니다. 특정 IP 패턴, 실패한 로그인 시도, 비정상 명령어 패턴 등을 빠르게 식별할 수 있습니다. |
| **4** | **프로세스 관리(Process Management)** | 포그라운드/백그라운드 프로세스 전환(`fg`, `bg`, `&`), 프로세스 상태 조회(`ps`, `pstree`), 시그널 전송(`kill`), 주기적 작업 스케줄링(`cron`, `at`) 등 실행 중인 프로세스를 제어하는 기술입니다. | **악성 프로세스 탐지 및 종료**, **시스템 리소스 관리**, **정기 백업/로그 로테이션** 등 시스템 운영 및 보안의 기본입니다. 좀비 프로세스 탐지와 cron을 통한 자동화된 모니터링이 핵심입니다. |

---

## 2. 실습 코드 & 응용 (Practice & Code Walkthrough)

### (A) 핵심 명령어/함수 실습

**리다이렉션 & 파이프 실습:**
```bash
# 표준 출력과 표준 에러를 분리하여 저장
ls /etc/passwd /etc/password > result.txt 2> error.txt

# 표준 출력과 에러를 모두 하나의 파일로 저장 (순서 중요!)
ls /etc/passwd /etc/password > result.txt 2>&1

# noclobber 옵션으로 덮어쓰기 방지
set -o noclobber
echo "new" > test  # 실패 (파일이 이미 존재)
echo "append" >> test  # 성공 (추가 모드)
set +o noclobber  # 해제

# 파이프를 활용한 로그 분석
cat /etc/passwd | grep /home | cut -d':' -f1
ls /etc/rc5.d | sort -r | grep S > result.txt

# tee: 화면 출력과 파일 저장 동시 수행
ls /etc/rc5.d | sort -r | tee result.txt | grep S
```

**정규식 & grep 실습:**
```bash
# 3자리 숫자가 있는 행 검색
cat /etc/passwd | grep '\<[0-9]\{3\}\>'

# x:로 시작하며 3자리 숫자가 있는 행
cat /etc/passwd | grep '\<x:[0-9]\{3\}\>'

# 소문자가 최소 9개 연속으로 나오는 패턴
grep '[a-z]\{9\}' /etc/passwd

# 대소문자 구분 없이 검색 + 라인 번호 출력
grep -in 'snmp' /etc/services

# 특정 패턴이 없는 행만 출력 (역검색)
grep -v 'root' /etc/passwd > temp
```

**awk를 활용한 데이터 처리:**
```bash
# root를 포함하는 행의 1, 2번째 필드 출력
awk '/root/ {print $1,$2}' /etc/passwd

# : 구분자로 지정하여 1, 3번째 필드 출력
awk -F : '/root/ {print $1,$3}' /etc/passwd

# n 또는 s로 시작하는 행의 첫 번째 필드
awk '/^[ns]/ {print $1}' /etc/protocols

# 두 번째 필드가 80000보다 큰 행만 출력
df | awk '$2 > 80000'

# Match 연산자(~)로 정규식 패턴 검색
awk '$1 ~ /ipv[46]/' /etc/protocols
```

**프로세스 관리 실습:**
```bash
# 백그라운드로 프로세스 실행
cp -R /usr/sbin/ /tmp/ &
jobs -l

# 포그라운드 프로세스를 백그라운드로 전환
find / -name '*.txt' 2>/dev/null > list.txt
# CTRL+Z로 일시 정지
bg  # 백그라운드로 전환

# 프로세스 상태 조회
ps -au  # 전체 사용자의 프로세스
ps -eLf | more  # 스레드 정보 포함
ps -U root -u root u  # root 프로세스만
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | more  # 메모리 사용량 순 정렬

# 좀비 프로세스 탐지
ps aux | awk '{print $8" "$2}' | grep -w Z

# 프로세스 종료 (시그널 전송)
kill -9 <PID>  # SIGKILL: 강제 종료
kill -15 <PID>  # SIGTERM: 정상 종료 (기본값)
kill -HUP <PID>  # SIGHUP: 설정 파일 재로드
```

**작업 스케줄링:**
```bash
# at: 일회성 작업 예약
echo "find / -name \"*.txt\" 2>/dev/null > /backup/at_list.txt" > /backup/at_test.sh
chmod a+x /backup/at_test.sh
at -t 202511272230 -f /backup/at_test.sh
atq  # 예약 작업 확인

# cron: 주기적 작업 스케줄링
crontab -e
# 매분마다 실행 예시:
# * * * * * echo "`date` crontab test" >> /backup/crontab.txt

# crontab 형식: 분 시 일 월 요일 명령어
# 예: 매일 새벽 3시 백업
# 0 3 * * * /backup/backup_script.sh
```

### (B) 실습 결과 및 분석

* **리다이렉션 순서의 중요성:** `2>&1 > file`과 `> file 2>&1`은 결과가 다릅니다. 후자가 표준 출력과 에러를 모두 파일로 보내는 올바른 방법입니다. 리다이렉션은 **왼쪽에서 오른쪽 순서**로 처리됩니다.

* **파이프의 효율성:** 대용량 로그 파일 분석 시 중간 파일을 생성하지 않고 메모리상에서 데이터를 스트리밍하므로 디스크 I/O를 크게 줄이고 처리 속도를 향상시킵니다.

* **정규식의 강력함:** 단순 문자열 검색을 넘어 복잡한 패턴 매칭이 가능합니다. `\{n,m\}` 반복 지정자, `^`/`$` 행 앵커, `\<`/`\>` 단어 경계 등을 조합하면 정교한 검색이 가능합니다.

* **프로세스 상태 필드 이해:** `ps` 명령의 STAT 필드에서 `R`(실행중), `S`(대기), `D`(디스크 대기), `Z`(좀비), `T`(정지) 등의 상태를 구분하여 시스템 성능 문제나 비정상 프로세스를 신속히 파악할 수 있습니다.

* **cron vs at의 차이:** `cron`은 **반복적 작업**(백업, 로그 로테이션, 모니터링)에, `at`은 **일회성 작업**(특정 시각에 한 번만 실행)에 적합합니다.

---

## 3. 실무/보안 관점 분석 (Insight & Scenario Mapping)

| 분야 | 적용 시나리오 |
|:---:|:---|
| **SOC / 관제** | 실시간 로그 모니터링 스크립트: `tail -f /var/log/auth.log \| grep -E "Failed\|Invalid" \| tee -a /var/log/security_alert.log`. 실패한 로그인 시도를 실시간으로 탐지하고 별도 알림 파일에 기록합니다. `cron`을 통해 매시간 로그를 집계하여 임계치 초과 시 알림을 발송하는 자동화 구축 가능합니다. |
| **CERT / 사고 대응** | 침해 사고 시 악성 프로세스 탐지: `ps aux \| grep -E "nc\|ncat\|/tmp/" \| grep -v grep`. 비정상 경로(`/tmp/`)에서 실행되거나 네트워크 도구(netcat 등)를 사용하는 의심 프로세스를 신속히 식별합니다. 좀비 프로세스 대량 발생은 **시스템 리소스 고갈 공격**의 징후일 수 있어 주기적 모니터링이 필수입니다. |
| **시스템 운영** | 정기 백업 자동화: `crontab -e`로 `0 2 * * * tar -czf /backup/daily_$(date +\%Y\%m\%d).tar.gz /var/www/html 2>&1 \| logger -t backup`을 등록하여 매일 새벽 2시 백업을 수행하고, 에러는 syslog에 자동 기록되도록 설정합니다. 디스크 사용량 모니터링: `df \| awk '$5 > 80 {print $0}' \| mail -s "Disk Alert" admin@example.com`을 cron에 등록하여 80% 초과 시 알림 발송합니다. |

---

## 4. 개인 인사이트 및 다음 단계 (Reflection & Next Steps)

* **배운 점/느낀 점:** Shell의 **I/O 리다이렉션과 파이프**는 단순해 보이지만 조합하면 매우 강력한 데이터 처리 파이프라인을 구축할 수 있습니다. 특히 **정규식**은 처음에는 복잡했지만, 패턴 문법을 익히고 나니 로그 분석에서 "바늘을 찾는" 도구가 아닌 "정확한 패턴을 한 번에 추출하는" 강력한 무기로 느껴졌습니다. **프로세스 관리**는 시스템 운영의 기본이자 보안 위협 대응의 출발점임을 확실히 깨달았습니다. `cron`의 자동화 능력은 반복 작업에서 인간 실수를 제거하고 일관성을 보장하는 핵심 기술입니다.

* **심화 방향:**
  - **고급 정규식**: `sed`를 활용한 대량 치환 작업과 복잡한 정규식 패턴 조합 연습
  - **Shell Script 작성**: 오늘 학습한 파이프, 정규식, 프로세스 관리를 결합하여 **종합 모니터링 스크립트** 작성 (로그 분석 → 임계치 체크 → 알림 전송)
  - **systemd와 프로세스 관리**: 최신 리눅스 시스템에서 `systemctl`을 활용한 서비스 관리 및 로그 분석(`journalctl`)
  - **실전 시나리오 연습**: 실제 공격 로그를 다운받아 정규식과 awk로 공격자 IP, 공격 시간대, 공격 패턴 등을 추출하고 리포트 자동 생성

---

## 5. 추가 참고사항 (Quick Reference)

### 정규식 주요 메타문자
```
^        : 행의 시작
$        : 행의 끝
.        : 임의의 한 문자 (개행 제외)
*        : 앞 문자 0회 이상 반복
[]       : 문자 집합 (예: [a-z], [0-9])
\{n,m\}  : 앞 문자 n~m회 반복
\<       : 단어의 시작
\>       : 단어의 끝
\        : 특수 문자 이스케이프
```

### 주요 시그널
```
SIGHUP (1)   : 설정 파일 재로드
SIGINT (2)   : Ctrl+C (인터럽트)
SIGKILL (9)  : 강제 종료 (차단 불가)
SIGTERM (15) : 정상 종료 요청 (기본값)
SIGSTOP (19) : 프로세스 일시 정지
```

### crontab 형식
```
* * * * * 명령어
│ │ │ │ │
│ │ │ │ └─ 요일 (0-7, 0과 7은 일요일)
│ │ │ └─── 월 (1-12)
│ │ └───── 일 (1-31)
│ └─────── 시 (0-23)
└───────── 분 (0-59)

예시:
0 2 * * *        # 매일 새벽 2시
*/10 * * * *     # 매 10분마다
0 0 * * 0        # 매주 일요일 자정
```
